{"task_id": "1", "round": 2, "temperature": 0.1, "generated_code": "import pytest\n\nR = 3\nC = 3\n\ndef min_cost(cost, m, n): \n    if not cost or not cost[0]:\n        raise IndexError(\"Cost matrix is empty\")\n    \n    tc = [[0 for x in range(n + 1)] for x in range(m + 1)] \n    tc[0][0] = cost[0][0] \n    \n    for i in range(1, m + 1): \n        tc[i][0] = tc[i - 1][0] + cost[i][0] \n    for j in range(1, n + 1): \n        tc[0][j] = tc[0][j - 1] + cost[0][j] \n    \n    for i in range(1, m + 1): \n        for j in range(1, n + 1): \n            tc[i][j] = min(tc[i - 1][j], tc[i][j - 1], tc[i - 1][j - 1]) + cost[i][j] \n            \n    return tc[m][n]\n\ndef test_basic_functionality():\n    cost_matrix = [[1, 2, 3], \n                   [4, 8, 2], \n                   [1, 5, 3]]\n    assert min_cost(cost_matrix, 2, 2) == 8, \"Should be 8\"\n\ndef test_another_basic_case():\n    cost_matrix = [[1, 3, 5], \n                   [2, 1, 2], \n                   [4, 3, 1]]\n    assert min_cost(cost_matrix, 2, 2) == 5, \"Should be 5\"\n\ndef test_edge_case_empty_matrix():\n    with pytest.raises(IndexError):\n        min_cost([], 0, 0)\n\ndef test_edge_case_single_element():\n    cost_matrix = [[5]]\n    assert min_cost(cost_matrix, 0, 0) == 5, \"Should be 5\"\n\ndef test_edge_case_large_matrix():\n    cost_matrix = [[1]*100 for _ in range(100)]\n    assert min_cost(cost_matrix, 99, 99) == 198, \"Should be 198\"\n\ndef test_exceptions_invalid_input():\n    with pytest.raises(IndexError):\n        min_cost([[1, 2], [3, 4]], 2, 2)\n\ndef test_exceptions_non_integer_cost():\n    with pytest.raises(TypeError):\n        min_cost([[1, 2], [3, 'a']], 1, 1)", "tests_source": "initial_tests.jsonl", "tests_task_id": "1", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T11:48:31.208892", "stage": "code_repair"}
{"task_id": "4", "round": 2, "temperature": 0.1, "generated_code": "import heapq as hq\n\ndef heap_queue_largest(nums, n):\n    if not isinstance(nums, list):\n        raise TypeError(\"Expected a list of numbers\")\n    if not all(isinstance(x, (int, float)) for x in nums):\n        raise TypeError(\"Expected a list of numbers\")\n    if n < 1:\n        raise ValueError(\"n must be a positive integer\")\n    \n    largest_nums = hq.nlargest(n, nums)\n    return largest_nums", "tests_source": "initial_tests.jsonl", "tests_task_id": "4", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T11:49:28.084499", "stage": "code_repair"}
{"task_id": "5", "round": 2, "temperature": 0.1, "generated_code": "def count_ways(n): \n    if not isinstance(n, int) or n < 0:\n        raise TypeError(\"unsupported operand type\")\n    \n    A = [0] * (n + 1) \n    B = [0] * (n + 1) \n    A[0] = 1\n    A[1] = 0\n    B[0] = 0\n    B[1] = 1\n    \n    for i in range(2, n + 1): \n        A[i] = A[i - 2] + 2 * B[i - 1] \n        B[i] = A[i - 1] + B[i - 2] \n    \n    return A[n]", "tests_source": "initial_tests.jsonl", "tests_task_id": "5", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T11:49:45.428570", "stage": "code_repair"}
{"task_id": "6", "round": 2, "temperature": 0.1, "generated_code": "def is_Power_Of_Two(x): \n    return x and (not(x & (x - 1))) \n\ndef differ_At_One_Bit_Pos(a, b): \n    if not isinstance(a, int) or not isinstance(b, int):\n        raise TypeError(\"Both arguments must be integers\")\n    return is_Power_Of_Two(a ^ b) and (a != b)", "tests_source": "initial_tests.jsonl", "tests_task_id": "6", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T11:50:06.988409", "stage": "code_repair"}
{"task_id": "7", "round": 2, "temperature": 0.1, "generated_code": "import re\n\ndef find_char_long(text):\n    if not isinstance(text, str):\n        raise TypeError(\"expected string or bytes-like object\")\n    return re.findall(r'\\b\\w{4,}\\b', text)", "tests_source": "initial_tests.jsonl", "tests_task_id": "7", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T11:50:19.434805", "stage": "code_repair"}
{"task_id": "9", "round": 2, "temperature": 0.1, "generated_code": "def find_Rotations(str): \n    if not isinstance(str, str):\n        raise TypeError(\"must be str\")\n    \n    n = len(str)\n    if n == 0:\n        return 0\n    \n    tmp = str + str\n    for i in range(1, n + 1): \n        substring = tmp[i: i+n] \n        if str == substring: \n            return i \n    return n", "tests_source": "initial_tests.jsonl", "tests_task_id": "9", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T11:50:42.036576", "stage": "code_repair"}
{"task_id": "10", "round": 2, "temperature": 0.1, "generated_code": "import heapq\n\ndef small_nnum(list1, n):\n    if not isinstance(list1, list):\n        raise TypeError(f\"Expected list, got {type(list1)}\")\n    if not isinstance(n, int):\n        raise TypeError(f\"Expected int, got {type(n)}\")\n    if n < 0:\n        raise ValueError(\"n must be non-negative\")\n    if n > len(list1):\n        n = len(list1)\n    \n    smallest = heapq.nsmallest(n, list1)\n    return smallest", "tests_source": "initial_tests.jsonl", "tests_task_id": "10", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T11:51:00.284773", "stage": "code_repair"}
{"task_id": "11", "round": 2, "temperature": 0.1, "generated_code": "def remove_Occ(s, ch): \n    if s is None or ch is None:\n        raise TypeError(\"Input cannot be None\")\n    \n    first_index = s.find(ch)\n    last_index = s.rfind(ch)\n    \n    if first_index == -1 or first_index == last_index:\n        return s.replace(ch, \"\", 1) if first_index != -1 else s\n    \n    return s[:first_index] + s[first_index + 1:last_index] + s[last_index + 1:]\n\nimport pytest\n\ndef test_remove_first_and_last_occurrence_basic():\n    assert remove_Occ(\"hello world\", \"o\") == \"hell wrld\", \"Should remove first and last 'o'\"\n    assert remove_Occ(\"banana\", \"a\") == \"banan\", \"Should remove first and last 'a'\"\n\ndef test_remove_first_and_last_occurrence_no_occurrence():\n    assert remove_Occ(\"hello world\", \"x\") == \"hello world\", \"Should return the same string if character not found\"\n    assert remove_Occ(\"test\", \"z\") == \"test\", \"Should return the same string if character not found\"\n\ndef test_remove_first_and_last_occurrence_edge_cases():\n    assert remove_Occ(\"\", \"a\") == \"\", \"Should return empty string when input is empty\"\n    assert remove_Occ(\"a\", \"a\") == \"\", \"Should return empty string when input is a single character that is removed\"\n    assert remove_Occ(\"aa\", \"a\") == \"\", \"Should return empty string when input is two identical characters that are removed\"\n    assert remove_Occ(\"abcabc\", \"a\") == \"bcab\", \"Should remove first and last 'a' from 'abcabc'\"\n\ndef test_remove_first_and_last_occurrence_exceptions():\n    with pytest.raises(TypeError):\n        remove_Occ(None, \"a\")\n    with pytest.raises(TypeError):\n        remove_Occ(\"test\", None)\n    with pytest.raises(TypeError):\n        remove_Occ(None, None)", "tests_source": "initial_tests.jsonl", "tests_task_id": "11", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T11:51:25.705114", "stage": "code_repair"}
{"task_id": "12", "round": 2, "temperature": 0.1, "generated_code": "def sort_matrix(M):\n    if not isinstance(M, list):\n        raise TypeError(\"expected an iterable\")\n    if any(not isinstance(row, list) for row in M):\n        raise TypeError(\"expected an iterable\")\n    if len(M) > 0 and any(len(row) != len(M[0]) for row in M):\n        raise ValueError(\"all rows must have the same length\")\n    \n    result = sorted(M, key=sum)\n    return result", "tests_source": "initial_tests.jsonl", "tests_task_id": "12", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T11:51:56.807889", "stage": "code_repair"}
{"task_id": "13", "round": 2, "temperature": 0.1, "generated_code": "from collections import Counter\n\ndef count_common(words):\n    if not isinstance(words, list):\n        raise TypeError(\"Input must be a list\")\n    for word in words:\n        if not isinstance(word, str):\n            raise TypeError(\"All elements in the list must be strings\")\n    \n    word_counts = Counter(words)\n    top_four = word_counts.most_common(4)\n    return top_four", "tests_source": "initial_tests.jsonl", "tests_task_id": "13", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T11:52:13.566262", "stage": "code_repair"}
{"task_id": "15", "round": 2, "temperature": 0.1, "generated_code": "import re\n\ndef split_lowerstring(text):\n    if not isinstance(text, str):\n        raise TypeError(\"expected a string\")\n    return re.findall('[a-z][^a-z]*', text)", "tests_source": "initial_tests.jsonl", "tests_task_id": "15", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T11:52:38.584171", "stage": "code_repair"}
{"task_id": "18", "round": 2, "temperature": 0.1, "generated_code": "NO_OF_CHARS = 256\n\ndef str_to_list(string): \n    temp = [] \n    for x in string: \n        temp.append(x) \n    return temp \n\ndef lst_to_string(List): \n    return ''.join(List) \n\ndef get_char_count_array(string): \n    count = [0] * NO_OF_CHARS \n    for i in string: \n        count[ord(i)] += 1\n    return count \n\ndef remove_dirty_chars(string, second_string): \n    if not isinstance(string, str) or not isinstance(second_string, str):\n        raise TypeError(\"Both arguments must be strings\")\n    \n    count = get_char_count_array(second_string) \n    ip_ind = 0\n    res_ind = 0\n    str_list = str_to_list(string) \n    while ip_ind != len(str_list): \n        temp = str_list[ip_ind] \n        if count[ord(temp)] == 0: \n            str_list[res_ind] = str_list[ip_ind] \n            res_ind += 1\n        ip_ind += 1\n    return lst_to_string(str_list[0:res_ind])", "tests_source": "initial_tests.jsonl", "tests_task_id": "18", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T11:53:13.827402", "stage": "code_repair"}
{"task_id": "23", "round": 2, "temperature": 0.1, "generated_code": "def maximum_Sum(list1): \n    if list1 == []:\n        return -100000\n    maxi = -100000\n    for x in list1: \n        if not isinstance(x, list):\n            raise TypeError(\"All elements must be lists\")\n        sum = 0 \n        for y in x: \n            if not isinstance(y, (int, float)):\n                raise TypeError(\"All elements must be numbers\")\n            sum += y      \n        maxi = max(sum, maxi)     \n    return maxi", "tests_source": "initial_tests.jsonl", "tests_task_id": "23", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T11:54:42.712867", "stage": "code_repair"}
{"task_id": "24", "round": 2, "temperature": 0.1, "generated_code": "def binary_to_decimal(binary): \n    if isinstance(binary, str) and binary == \"\":\n        raise ValueError(\"Invalid binary number\")\n    if isinstance(binary, str):\n        if not all(char in '01' for char in binary):\n            raise ValueError(\"Invalid binary number\")\n        binary = int(binary)\n    if binary < 0:\n        raise ValueError(\"Invalid binary number\")\n    \n    decimal, i = 0, 0\n    while binary != 0: \n        dec = binary % 10\n        decimal += dec * pow(2, i) \n        binary //= 10\n        i += 1\n    return decimal", "tests_source": "initial_tests.jsonl", "tests_task_id": "24", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T11:55:00.274591", "stage": "code_repair"}
{"task_id": "25", "round": 2, "temperature": 0.1, "generated_code": "def find_Product(arr, n): \n    if arr is None or n is None or n < 0:\n        raise TypeError(\"Invalid input\")\n    \n    from collections import Counter\n    count = Counter(arr)\n    prod = 1\n    found_non_repeated = False\n    \n    for num in count:\n        if count[num] == 1:\n            prod *= num\n            found_non_repeated = True\n            \n    return prod if found_non_repeated else 1", "tests_source": "initial_tests.jsonl", "tests_task_id": "25", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T11:55:20.809197", "stage": "code_repair"}
{"task_id": "30", "round": 2, "temperature": 0.1, "generated_code": "def check_Equality(s): \n    return (ord(s[0]) == ord(s[len(s) - 1])); \n\ndef count_Substring_With_Equal_Ends(s): \n    if not isinstance(s, str):\n        raise TypeError(\"expected a string\")\n    \n    result = 0; \n    n = len(s); \n    for i in range(n): \n        for j in range(1, n - i + 1):  \n            if (check_Equality(s[i:i+j])): \n                result += 1; \n    return result;", "tests_source": "initial_tests.jsonl", "tests_task_id": "30", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T11:56:27.261444", "stage": "code_repair"}
{"task_id": "31", "round": 2, "temperature": 0.1, "generated_code": "def func(nums, k):\n    import collections\n    d = collections.defaultdict(int)\n    for row in nums:\n        for i in row:\n            d[i] += 1\n    temp = []\n    import heapq\n    for key, v in d.items():\n        if len(temp) < k:\n            heapq.heappush(temp, (v, key))\n        else:\n            if v > temp[0][0]:\n                heapq.heappop(temp)\n                heapq.heappush(temp, (v, key))\n    result = []\n    while temp:\n        v, key = heapq.heappop(temp)\n        result.append(key)\n    return result[::-1]", "tests_source": "initial_tests.jsonl", "tests_task_id": "31", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T11:56:47.145866", "stage": "code_repair"}
{"task_id": "33", "round": 2, "temperature": 0.1, "generated_code": "def decimal_To_Binary(N): \n    if not isinstance(N, int):\n        raise TypeError(\"unsupported operand type\")\n    \n    if N < 0:\n        N = (1 << 32) + N  # Convert to two's complement for negative numbers\n    \n    B_Number = 0\n    cnt = 0\n    while (N != 0): \n        rem = N % 2\n        c = pow(10, cnt)  \n        B_Number += rem * c  \n        N //= 2 \n        cnt += 1\n    return B_Number", "tests_source": "initial_tests.jsonl", "tests_task_id": "33", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T11:57:21.522081", "stage": "code_repair"}
{"task_id": "34", "round": 2, "temperature": 0.1, "generated_code": "def find_missing(ar, N): \n    if ar is None:\n        raise TypeError(\"Input cannot be None\")\n    if not isinstance(ar, list):\n        raise TypeError(\"Input must be a list\")\n    \n    l = 0\n    r = N - 1\n    if N == 0:\n        return -1\n    \n    while (l <= r):  \n        mid = (l + r) // 2\n        if mid == 0:\n            if ar[mid] != 1:\n                return 1\n            else:\n                l = mid + 1\n        elif ar[mid] != mid + 1 and ar[mid - 1] == mid:\n            return mid + 1  \n        elif ar[mid] != mid + 1: \n            r = mid - 1 \n        else: \n            l = mid + 1\n            \n    return -1", "tests_source": "initial_tests.jsonl", "tests_task_id": "34", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T11:57:44.801808", "stage": "code_repair"}
{"task_id": "36", "round": 2, "temperature": 0.1, "generated_code": "def find_Nth_Digit(p, q, N):\n    if q == 0:\n        raise ZeroDivisionError(\"division by zero\")\n    if N <= 0:\n        raise ValueError(\"N must be a positive integer\")\n    \n    p = p % q  # Ensure p is within the bounds of q\n    while N > 0:\n        N -= 1\n        p *= 10\n        res = p // q\n        p %= q\n    return res", "tests_source": "initial_tests.jsonl", "tests_task_id": "36", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T11:58:24.452164", "stage": "code_repair"}
{"task_id": "38", "round": 2, "temperature": 0.1, "generated_code": "def div_even_odd(list1):\n    first_even = next((el for el in list1 if isinstance(el, (int, float)) and el % 2 == 0), -1)\n    first_odd = next((el for el in list1 if isinstance(el, (int, float)) and el % 2 != 0), -1)\n    \n    if first_even == -1 or first_odd == -1:\n        return -1\n    if first_odd == 0:\n        raise ZeroDivisionError(\"division by zero\")\n    \n    return first_even / first_odd", "tests_source": "initial_tests.jsonl", "tests_task_id": "38", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T11:58:51.126741", "stage": "code_repair"}
{"task_id": "39", "round": 2, "temperature": 0.1, "generated_code": "import heapq\nfrom collections import Counter\n\ndef rearange_string(S):\n    if not isinstance(S, str):\n        raise TypeError(\"Input must be a string\")\n    \n    ctr = Counter(S)\n    heap = [(-value, key) for key, value in ctr.items()]\n    heapq.heapify(heap)\n    \n    if (-heap[0][0]) * 2 > len(S) + 1: \n        return \"\"\n    \n    ans = []\n    while len(heap) >= 2:\n        nct1, char1 = heapq.heappop(heap)\n        nct2, char2 = heapq.heappop(heap)\n        ans.extend([char1, char2])\n        if nct1 + 1: heapq.heappush(heap, (nct1 + 1, char1))\n        if nct2 + 1: heapq.heappush(heap, (nct2 + 1, char2))\n    \n    if heap:\n        ans.append(heap[0][1])\n    \n    return \"\".join(ans)", "tests_source": "initial_tests.jsonl", "tests_task_id": "39", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T11:59:15.088760", "stage": "code_repair"}
{"task_id": "40", "round": 2, "temperature": 0.1, "generated_code": "from collections import Counter\nfrom itertools import chain\n\ndef freq_element(nums):\n    if not isinstance(nums, (list, tuple)):\n        raise TypeError(\"expected an iterable\")\n    result = Counter(chain.from_iterable(nums))\n    return result", "tests_source": "initial_tests.jsonl", "tests_task_id": "40", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T11:59:33.390692", "stage": "code_repair"}
{"task_id": "42", "round": 2, "temperature": 0.1, "generated_code": "def find_Sum(arr, n): \n    return sum(set(x for x in arr if arr.count(x) > 1))\n\nimport pytest\n\ndef test_basic_functionality_with_repeated_elements():\n    assert find_Sum([1, 2, 3, 1, 2], 5) == 3, \"Should return the sum of repeated elements (1 + 2)\"\n    assert find_Sum([4, 5, 6, 4, 5, 4], 6) == 13, \"Should return the sum of repeated elements (4 + 5 + 4)\"\n    assert find_Sum([7, 8, 9, 10], 4) == 0, \"Should return 0 as there are no repeated elements\"\n\ndef test_edge_cases():\n    assert find_Sum([], 0) == 0, \"Should return 0 for an empty array\"\n    assert find_Sum([1], 1) == 0, \"Should return 0 for a single element array\"\n    assert find_Sum([1, 1], 2) == 1, \"Should return 1 for an array with two identical elements\"\n\ndef test_exceptions():\n    with pytest.raises(TypeError, match=\"unsupported operand type\"):\n        find_Sum(None, 0)\n    with pytest.raises(TypeError, match=\"unsupported operand type\"):\n        find_Sum(\"string\", 0)\n    with pytest.raises(TypeError, match=\"unsupported operand type\"):\n        find_Sum([1, 2, 3], \"three\")", "tests_source": "initial_tests.jsonl", "tests_task_id": "42", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T12:00:01.491909", "stage": "code_repair"}
{"task_id": "47", "round": 2, "temperature": 0.1, "generated_code": "def compute_Last_Digit(A, B): \n    if not isinstance(A, int) or not isinstance(B, int):\n        raise TypeError(\"Inputs must be integers\")\n    if A < 0 or B < 0:\n        raise ValueError(\"Inputs must be non-negative integers\")\n    \n    variable = 1\n    if (A == B): \n        return 1\n    elif ((B - A) >= 5):  \n        return 0\n    else:   \n        for i in range(A + 1, B + 1): \n            variable = (variable * (i % 10)) % 10\n        return variable % 10", "tests_source": "initial_tests.jsonl", "tests_task_id": "47", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T12:01:10.478687", "stage": "code_repair"}
{"task_id": "48", "round": 2, "temperature": 0.1, "generated_code": "def odd_bit_set_number(n):\n    if not isinstance(n, int):\n        raise TypeError(\"unsupported operand type\")\n    \n    res = 0\n    for i in range(32):  # Assuming a 32-bit integer\n        if i % 2 == 1:  # Set odd bits\n            res |= (1 << i)\n    \n    return n | res", "tests_source": "initial_tests.jsonl", "tests_task_id": "48", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T12:01:34.718692", "stage": "code_repair"}
{"task_id": "49", "round": 2, "temperature": 0.1, "generated_code": "def specified_element(nums, N):\n    result = []\n    for i in nums:\n        if len(i) > N:\n            result.append(i[N])\n    return result", "tests_source": "initial_tests.jsonl", "tests_task_id": "49", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T12:01:50.792614", "stage": "code_repair"}
{"task_id": "50", "round": 2, "temperature": 0.1, "generated_code": "def min_length_list(input_list):\n    if not input_list:\n        raise ValueError(\"min() arg is an empty sequence\")\n    \n    for item in input_list:\n        if not isinstance(item, str):\n            raise TypeError(\"object of type 'int' has no len()\")\n    \n    min_length = min(len(x) for x in input_list)  \n    min_list = min(input_list, key=lambda i: len(i))\n    return (min_length, min_list)", "tests_source": "initial_tests.jsonl", "tests_task_id": "50", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T12:02:10.665532", "stage": "code_repair"}
{"task_id": "53", "round": 2, "temperature": 0.1, "generated_code": "def check_Equality(str):\n    if not isinstance(str, str):\n        raise TypeError(\"Input must be a string\")\n    if len(str) == 0:\n        return \"Equal\"\n    if str[0] == str[-1]:\n        return \"Equal\"\n    else:\n        return \"Not Equal\"", "tests_source": "initial_tests.jsonl", "tests_task_id": "53", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T12:02:49.732322", "stage": "code_repair"}
{"task_id": "55", "round": 2, "temperature": 0.1, "generated_code": "import math\n\ndef tn_gp(a, n, r):\n    if not isinstance(a, (int, float)):\n        raise TypeError(\"unsupported operand type\")\n    if not isinstance(n, int) or n <= 0:\n        raise ValueError(\"n must be a positive integer\")\n    if not isinstance(r, (int, float)):\n        raise TypeError(\"unsupported operand type\")\n    \n    tn = a * (math.pow(r, n - 1))\n    return tn", "tests_source": "initial_tests.jsonl", "tests_task_id": "55", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T12:03:15.576832", "stage": "code_repair"}
{"task_id": "56", "round": 2, "temperature": 0.1, "generated_code": "def rev(num):    \n    rev_num = 0\n    while (num > 0):  \n        rev_num = (rev_num * 10 + num % 10) \n        num = num // 10  \n    return rev_num  \n\ndef check(n):    \n    if not isinstance(n, int) or n < 0:\n        return False\n    return (2 * rev(n) == n + 1)", "tests_source": "initial_tests.jsonl", "tests_task_id": "56", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T12:03:31.690534", "stage": "code_repair"}
{"task_id": "57", "round": 2, "temperature": 0.1, "generated_code": "def find_Max_Num(arr, n):\n    if not isinstance(arr, list) or any(not isinstance(x, int) for x in arr):\n        raise TypeError(\"unsupported operand type\")\n    if n > len(arr):\n        raise ValueError(\"not enough values to unpack\")\n    \n    arr = [str(x) for x in arr]\n    arr.sort(key=lambda x: x * 10, reverse=True)\n    return int(''.join(arr))\n\nimport pytest\n\ndef test_basic_functionality():\n    assert find_Max_Num([3, 30, 34, 5, 9], 5) == 9534330, \"Should form the largest number 9534330\"\n    assert find_Max_Num([1, 2, 3], 3) == 321, \"Should form the largest number 321\"\n    assert find_Max_Num([0, 0, 0], 3) == 0, \"Should form the largest number 0\"\n\ndef test_edge_cases():\n    assert find_Max_Num([9, 8, 7], 3) == 987, \"Should form the largest number 987\"\n    assert find_Max_Num([1], 1) == 1, \"Should return the single digit 1\"\n    assert find_Max_Num([], 0) == 0, \"Should return 0 for empty input\"\n\ndef test_exceptions():\n    with pytest.raises(TypeError, match=\"unsupported operand type\"):\n        find_Max_Num(\"123\", 3)  # Invalid input type\n    with pytest.raises(TypeError, match=\"unsupported operand type\"):\n        find_Max_Num([1, 2, \"3\"], 3)  # Mixed types in input\n    with pytest.raises(ValueError, match=\"not enough values to unpack\"):\n        find_Max_Num([1], 2)  # n is greater than the length of arr", "tests_source": "initial_tests.jsonl", "tests_task_id": "57", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T12:03:52.911583", "stage": "code_repair"}
{"task_id": "58", "round": 2, "temperature": 0.1, "generated_code": "def opposite_Signs(x, y): \n    return (x < 0) != (y < 0)\n\nimport pytest\n\ndef test_opposite_signs_positive_negative():\n    assert opposite_Signs(5, -3) == True, \"5 and -3 should have opposite signs\"\n\ndef test_opposite_signs_negative_positive():\n    assert opposite_Signs(-7, 2) == True, \"-7 and 2 should have opposite signs\"\n\ndef test_opposite_signs_same_sign():\n    assert opposite_Signs(4, 3) == False, \"4 and 3 should not have opposite signs\"\n    assert opposite_Signs(-1, -5) == False, \"-1 and -5 should not have opposite signs\"\n\ndef test_opposite_signs_zero():\n    assert opposite_Signs(0, 5) == False, \"0 and 5 should not have opposite signs\"\n    assert opposite_Signs(0, -5) == False, \"0 and -5 should not have opposite signs\"\n\ndef test_opposite_signs_edge_cases():\n    assert opposite_Signs(1, -1) == True, \"1 and -1 should have opposite signs\"\n    assert opposite_Signs(-1, 1) == True, \"-1 and 1 should have opposite signs\"\n\ndef test_opposite_signs_large_numbers():\n    assert opposite_Signs(2147483647, -2147483648) == True, \"2147483647 and -2147483648 should have opposite signs\"\n    assert opposite_Signs(-2147483647, 2147483647) == True, \"-2147483647 and 2147483647 should have opposite signs\"\n\ndef test_opposite_signs_invalid_inputs():\n    with pytest.raises(TypeError, match=\"unsupported operand type\"):\n        opposite_Signs(\"a\", 5)\n    with pytest.raises(TypeError, match=\"unsupported operand type\"):\n        opposite_Signs(5, None)\n    with pytest.raises(TypeError, match=\"unsupported operand type\"):\n        opposite_Signs([], 5)", "tests_source": "initial_tests.jsonl", "tests_task_id": "58", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T12:04:20.272949", "stage": "code_repair"}
{"task_id": "59", "round": 2, "temperature": 0.1, "generated_code": "def is_octagonal(n): \n    if not isinstance(n, int):\n        raise TypeError(\"unsupported operand type\")\n    if n < 0:\n        raise ValueError(\"negative integer\")\n    return 3 * n * n - 2 * n", "tests_source": "initial_tests.jsonl", "tests_task_id": "59", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T12:04:41.744324", "stage": "code_repair"}
{"task_id": "60", "round": 2, "temperature": 0.1, "generated_code": "def max_len_sub(arr, n): \n    if arr is None or n is None or not isinstance(arr, list) or not isinstance(n, int):\n        raise TypeError(\"Invalid input types\")\n    if n < 0:\n        raise ValueError(\"Array length cannot be negative\")\n    \n    if n == 0:\n        return 0\n    \n    mls = [1] * n \n    max_length = 1\n    \n    for i in range(1, n): \n        for j in range(i): \n            if abs(arr[i] - arr[j]) <= 1: \n                mls[i] = max(mls[i], mls[j] + 1)\n        max_length = max(max_length, mls[i])\n    \n    return max_length", "tests_source": "initial_tests.jsonl", "tests_task_id": "60", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T12:05:03.465224", "stage": "code_repair"}
{"task_id": "61", "round": 2, "temperature": 0.1, "generated_code": "from collections import defaultdict\n\ndef count_Substrings(s, n):\n    if not isinstance(s, str):\n        raise TypeError(\"expected a string\")\n    if len(s) != n:\n        raise ValueError(\"n must be equal to the length of s\")\n    \n    count, sum = 0, 0\n    mp = defaultdict(lambda: 0)\n    mp[0] += 1\n    \n    for i in range(n):\n        sum += int(s[i])\n        count += mp[sum - (i + 1)]\n        mp[sum - (i + 1)] += 1\n        \n    return count", "tests_source": "initial_tests.jsonl", "tests_task_id": "61", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T12:05:25.144520", "stage": "code_repair"}
{"task_id": "62", "round": 2, "temperature": 0.1, "generated_code": "def smallest_num(xs):\n    if not xs:\n        raise ValueError(\"min() arg is an empty sequence\")\n    return min(xs)", "tests_source": "initial_tests.jsonl", "tests_task_id": "62", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T12:05:45.912051", "stage": "code_repair"}
{"task_id": "63", "round": 2, "temperature": 0.1, "generated_code": "def max_difference(test_list):\n    if not test_list:\n        return 0\n    temp = [abs(b - a) for a, b in test_list]\n    res = max(temp)\n    return res\n\nimport pytest\n\ndef test_basic_functionality():\n    assert max_difference([(1, 5), (2, 8), (3, 10)]) == 7, \"Should be 7 for pairs (1,5) and (3,10)\"\n    assert max_difference([(10, 20), (15, 25), (30, 40)]) == 20, \"Should be 20 for pairs (10,20) and (30,40)\"\n    assert max_difference([(0, 0), (1, 1), (2, 2)]) == 0, \"Should be 0 for pairs with the same values\"\n\ndef test_edge_cases():\n    assert max_difference([(1, 1)]) == 0, \"Should be 0 for a single pair (1,1)\"\n    assert max_difference([(1, 2), (2, 3)]) == 1, \"Should be 1 for pairs (1,2) and (2,3)\"\n    assert max_difference([]) == 0, \"Should return 0 for an empty list\"\n\ndef test_exceptions():\n    with pytest.raises(TypeError, match=\"unsupported operand type\"):\n        max_difference([(1, 'a'), (2, 3)])  # Invalid input with a string\n    with pytest.raises(TypeError, match=\"unsupported operand type\"):\n        max_difference([(None, 2), (3, 4)])  # Invalid input with None\n    with pytest.raises(ValueError, match=\"not enough values to unpack\"):\n        max_difference([(1,)])  # Invalid input with a single element tuple", "tests_source": "initial_tests.jsonl", "tests_task_id": "63", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T12:06:04.961462", "stage": "code_repair"}
{"task_id": "64", "round": 2, "temperature": 0.1, "generated_code": "def subject_marks(subjectmarks):\n    if not all(isinstance(item, tuple) and len(item) == 2 for item in subjectmarks):\n        raise TypeError(\"All elements must be tuples of length 2\")\n    if not all(isinstance(item[1], (int, float)) for item in subjectmarks):\n        raise TypeError(\"Second element of each tuple must be a number\")\n    \n    subjectmarks.sort(key=lambda x: x[1])\n    return subjectmarks", "tests_source": "initial_tests.jsonl", "tests_task_id": "64", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T12:06:29.035392", "stage": "code_repair"}
{"task_id": "67", "round": 2, "temperature": 0.1, "generated_code": "def bell_number(n):   \n    if n < 0:\n        raise IndexError(\"list index out of range\")\n    bell = [[0 for i in range(n+1)] for j in range(n+1)] \n    bell[0][0] = 1\n    for i in range(1, n+1): \n        bell[i][0] = bell[i-1][i-1]  \n        for j in range(1, i+1): \n            bell[i][j] = bell[i-1][j-1] + bell[i][j-1]   \n    return bell[n][0] \n\nimport pytest\n\ndef test_bell_number_basic_cases():\n    assert bell_number(0) == 1, \"Bell number for n=0 should be 1\"\n    assert bell_number(1) == 1, \"Bell number for n=1 should be 1\"\n    assert bell_number(2) == 2, \"Bell number for n=2 should be 2\"\n    assert bell_number(3) == 5, \"Bell number for n=3 should be 5\"\n    assert bell_number(4) == 15, \"Bell number for n=4 should be 15\"\n\ndef test_bell_number_edge_cases():\n    assert bell_number(5) == 52, \"Bell number for n=5 should be 52\"\n    assert bell_number(6) == 203, \"Bell number for n=6 should be 203\"\n    assert bell_number(7) == 877, \"Bell number for n=7 should be 877\"\n\ndef test_bell_number_boundary_cases():\n    assert bell_number(10) == 115975, \"Bell number for n=10 should be 115975\"\n    assert bell_number(15) == 6513215599, \"Bell number for n=15 should be 6513215599\"\n\ndef test_bell_number_exceptions():\n    with pytest.raises(IndexError, match=\"list index out of range\"):\n        bell_number(-1)\n    with pytest.raises(IndexError, match=\"list index out of range\"):\n        bell_number(1000)  # Assuming this is beyond the implementation limits", "tests_source": "initial_tests.jsonl", "tests_task_id": "67", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T12:07:11.386883", "stage": "code_repair"}
{"task_id": "69", "round": 2, "temperature": 0.1, "generated_code": "def is_sublist(l, s):\n    if l is None or s is None:\n        raise TypeError(\"Arguments cannot be None\")\n    \n    sub_set = False\n    if s == []:\n        sub_set = True\n    elif s == l:\n        sub_set = True\n    elif len(s) > len(l):\n        sub_set = False\n    else:\n        for i in range(len(l)):\n            if l[i] == s[0]:\n                n = 1\n                while (n < len(s)) and (i + n < len(l)) and (l[i + n] == s[n]):\n                    n += 1                \n                if n == len(s):\n                    sub_set = True\n    return sub_set", "tests_source": "initial_tests.jsonl", "tests_task_id": "69", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T12:07:58.132686", "stage": "code_repair"}
{"task_id": "70", "round": 2, "temperature": 0.1, "generated_code": "def find_equal_tuple(Input, k):\n    if not isinstance(Input, list) or not all(isinstance(t, tuple) for t in Input):\n        raise TypeError(\"Input must be a list of tuples\")\n    if not isinstance(k, int):\n        raise TypeError(\"k must be an integer\")\n    \n    flag = 1\n    for tuple in Input:\n        if len(tuple) != k:\n            flag = 0\n            break\n    return flag\n\ndef get_equal(Input, k):\n    if find_equal_tuple(Input, k) == 1:\n        return (\"All tuples have same length\")\n    else:\n        return (\"All tuples do not have same length\")", "tests_source": "initial_tests.jsonl", "tests_task_id": "70", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T12:08:20.861900", "stage": "code_repair"}
{"task_id": "73", "round": 2, "temperature": 0.1, "generated_code": "import re\n\ndef multiple_split(text):\n    if not isinstance(text, str):\n        raise TypeError(\"expected string or bytes-like object\")\n    return re.split(r'[;,\\*\\n]+', text)", "tests_source": "initial_tests.jsonl", "tests_task_id": "73", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T12:09:04.973285", "stage": "code_repair"}
{"task_id": "75", "round": 2, "temperature": 0.1, "generated_code": "def find_tuples(test_list, K):\n    if not isinstance(test_list, list) or not isinstance(K, int):\n        raise TypeError(\"Invalid input types\")\n    res = [sub for sub in test_list if all(isinstance(ele, int) and ele % K == 0 for ele in sub)]\n    return (str(res))", "tests_source": "initial_tests.jsonl", "tests_task_id": "75", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T12:09:34.064963", "stage": "code_repair"}
{"task_id": "76", "round": 2, "temperature": 0.1, "generated_code": "def count_Squares(m, n):\n    if not isinstance(m, int) or not isinstance(n, int):\n        raise TypeError(\"unsupported operand type\")\n    if m < 0 or n < 0:\n        return 0.0\n    if n < m:\n        temp = m\n        m = n\n        n = temp\n    return (m * (m + 1) * (2 * m + 1) / 6 + (n - m) * m * (m + 1) / 2)\n\nimport pytest\n\ndef test_basic_functionality():\n    assert count_Squares(2, 3) == 5.0, \"Should be 5 squares in a 2x3 rectangle\"\n    assert count_Squares(3, 3) == 14.0, \"Should be 14 squares in a 3x3 rectangle\"\n    assert count_Squares(1, 1) == 1.0, \"Should be 1 square in a 1x1 rectangle\"\n    assert count_Squares(4, 5) == 30.0, \"Should be 30 squares in a 4x5 rectangle\"\n\ndef test_edge_cases():\n    assert count_Squares(0, 0) == 0.0, \"Should be 0 squares in a 0x0 rectangle\"\n    assert count_Squares(1, 0) == 0.0, \"Should be 0 squares in a 1x0 rectangle\"\n    assert count_Squares(0, 1) == 0.0, \"Should be 0 squares in a 0x1 rectangle\"\n    assert count_Squares(1, 1) == 1.0, \"Should be 1 square in a 1x1 rectangle\"\n    assert count_Squares(10, 10) == 385.0, \"Should be 385 squares in a 10x10 rectangle\"\n\ndef test_exceptions():\n    with pytest.raises(TypeError, match=\"unsupported operand type\"):\n        count_Squares(\"a\", 3)\n    with pytest.raises(TypeError, match=\"unsupported operand type\"):\n        count_Squares(3, \"b\")\n    with pytest.raises(TypeError, match=\"unsupported operand type\"):\n        count_Squares(None, 3)\n    with pytest.raises(TypeError, match=\"unsupported operand type\"):\n        count_Squares(3, None)", "tests_source": "initial_tests.jsonl", "tests_task_id": "76", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T12:10:07.625496", "stage": "code_repair"}
{"task_id": "77", "round": 2, "temperature": 0.1, "generated_code": "def is_Diff(n):\n    if not isinstance(n, int):\n        raise TypeError(\"unsupported operand type\")\n    \n    sum_even = 0\n    sum_odd = 0\n    \n    for digit in str(abs(n)):\n        if int(digit) % 2 == 0:\n            sum_even += int(digit)\n        else:\n            sum_odd += int(digit)\n    \n    return (sum_even - sum_odd) == 0", "tests_source": "initial_tests.jsonl", "tests_task_id": "77", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T12:10:39.645633", "stage": "code_repair"}
{"task_id": "78", "round": 2, "temperature": 0.1, "generated_code": "def count_With_Odd_SetBits(n): \n    if n < 0:\n        raise TypeError(\"unsupported operand type\")\n    if (n % 2 != 0): \n        return (n + 1) // 2\n    count = 0\n    for i in range(1, n + 1):\n        if bin(i).count('1') % 2 != 0:\n            count += 1\n    return count", "tests_source": "initial_tests.jsonl", "tests_task_id": "78", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T12:10:58.709017", "stage": "code_repair"}
{"task_id": "81", "round": 2, "temperature": 0.1, "generated_code": "def zip_tuples(test_tup1, test_tup2):\n    if not isinstance(test_tup1, tuple) or not isinstance(test_tup2, tuple):\n        raise TypeError(\"Both arguments must be tuples\")\n    \n    res = []\n    len_tup2 = len(test_tup2)\n    \n    for i, j in enumerate(test_tup1):\n        if len_tup2 == 0:\n            res.append((j, None))\n        else:\n            res.append((j, test_tup2[i % len_tup2])) \n    return res", "tests_source": "initial_tests.jsonl", "tests_task_id": "81", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T12:11:33.691311", "stage": "code_repair"}
{"task_id": "83", "round": 2, "temperature": 0.1, "generated_code": "def get_Char(strr):  \n    if not isinstance(strr, str):\n        raise TypeError(\"string expected\")\n    \n    summ = 0\n    for i in range(len(strr)): \n        summ += (ord(strr[i]) - ord('a') + 1)  \n    \n    if (summ % 26 == 0): \n        return 'z' \n    else: \n        summ = summ % 26\n        return chr(ord('a') + summ - 1)\n\nimport pytest\n\ndef test_basic_functionality():\n    assert get_Char(\"abc\") == 'c', \"Expected 'c' for input 'abc'\"\n    assert get_Char(\"xyz\") == 'a', \"Expected 'a' for input 'xyz'\"\n    assert get_Char(\"hello\") == 'o', \"Expected 'o' for input 'hello'\"\n    assert get_Char(\"test\") == 's', \"Expected 's' for input 'test'\"\n    assert get_Char(\"a\") == 'a', \"Expected 'a' for input 'a'\"\n\ndef test_edge_cases():\n    assert get_Char(\"\") == 'z', \"Expected 'z' for empty input\"\n    assert get_Char(\"z\") == 'z', \"Expected 'z' for input 'z'\"\n    assert get_Char(\"a\" * 25) == 'y', \"Expected 'y' for input of 25 'a's\"\n    assert get_Char(\"a\" * 26) == 'z', \"Expected 'z' for input of 26 'a's\"\n    assert get_Char(\"a\" * 27) == 'a', \"Expected 'a' for input of 27 'a's\"\n\ndef test_exceptions():\n    with pytest.raises(TypeError, match=\"string expected\"):\n        get_Char(123)\n    with pytest.raises(TypeError, match=\"string expected\"):\n        get_Char(None)\n    with pytest.raises(TypeError, match=\"string expected\"):\n        get_Char([\"a\", \"b\", \"c\"])", "tests_source": "initial_tests.jsonl", "tests_task_id": "83", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T12:12:11.710965", "stage": "code_repair"}
{"task_id": "84", "round": 2, "temperature": 0.1, "generated_code": "def sequence(n): \n    if not isinstance(n, int) or n <= 0:\n        raise TypeError(\"Input must be a positive integer\")\n    if n == 1 or n == 2: \n        return 1\n    else: \n        return sequence(sequence(n-1)) + sequence(n - sequence(n-1))", "tests_source": "initial_tests.jsonl", "tests_task_id": "84", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T12:12:46.835185", "stage": "code_repair"}
{"task_id": "88", "round": 2, "temperature": 0.1, "generated_code": "import collections\n\ndef freq_count(list1):\n    if not isinstance(list1, list):\n        raise TypeError(\"Input must be a list\")\n    freq_count = collections.Counter(list1)\n    return freq_count", "tests_source": "initial_tests.jsonl", "tests_task_id": "88", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T12:13:27.156382", "stage": "code_repair"}
{"task_id": "92", "round": 2, "temperature": 0.1, "generated_code": "def is_undulating(n): \n    if not isinstance(n, list) or len(n) < 3: \n        return False\n    for i in range(2, len(n)): \n        if n[i - 2] != n[i]: \n            return False\n    return True", "tests_source": "initial_tests.jsonl", "tests_task_id": "92", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T12:14:07.647209", "stage": "code_repair"}
{"task_id": "94", "round": 2, "temperature": 0.1, "generated_code": "from operator import itemgetter \n\ndef index_minimum(test_list):\n    if not test_list:\n        raise ValueError(\"min() arg is an empty sequence\")\n    res = min(test_list, key=itemgetter(1))[0]\n    return res", "tests_source": "initial_tests.jsonl", "tests_task_id": "94", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T12:14:37.388389", "stage": "code_repair"}
{"task_id": "95", "round": 2, "temperature": 0.1, "generated_code": "def Find_Min_Length(lst):  \n    if not lst:\n        raise ValueError(\"min() arg is an empty sequence\")\n    \n    minLength = float('inf')\n    \n    for sublist in lst:\n        if not isinstance(sublist, list):\n            raise TypeError(f\"object of type '{type(sublist).__name__}' has no len()\")\n        minLength = min(minLength, len(sublist))\n    \n    return minLength if minLength != float('inf') else 0", "tests_source": "initial_tests.jsonl", "tests_task_id": "95", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T12:14:57.576248", "stage": "code_repair"}
{"task_id": "98", "round": 2, "temperature": 0.1, "generated_code": "import pytest\n\ndef multiply_num(numbers):  \n    if not isinstance(numbers, list):\n        raise TypeError(\"Input must be a list\")\n    if any(not isinstance(x, (int, float)) for x in numbers):\n        raise TypeError(\"All elements in the list must be numbers\")\n    if len(numbers) == 0:\n        raise ZeroDivisionError(\"Division by zero when length is zero\")\n    \n    total = 1\n    for x in numbers:\n        total *= x  \n    return total / len(numbers)", "tests_source": "initial_tests.jsonl", "tests_task_id": "98", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T12:15:35.989592", "stage": "code_repair"}
