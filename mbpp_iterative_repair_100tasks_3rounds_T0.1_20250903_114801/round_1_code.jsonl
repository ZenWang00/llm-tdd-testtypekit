{"task_id": "1", "round": 1, "temperature": 0.1, "generated_code": "def min_cost(cost, m, n): \n    if not cost or not cost[0]:\n        raise IndexError(\"Cost matrix is empty\")\n    \n    R = len(cost)\n    C = len(cost[0])\n    \n    if m >= R or n >= C:\n        raise IndexError(\"Invalid position (m, n) for the given cost matrix\")\n    \n    for row in cost:\n        if not all(isinstance(x, (int, float)) for x in row):\n            raise TypeError(\"Cost matrix must contain only integers or floats\")\n    \n    tc = [[0 for x in range(C)] for x in range(R)] \n    tc[0][0] = cost[0][0] \n    \n    for i in range(1, m + 1): \n        tc[i][0] = tc[i - 1][0] + cost[i][0] \n    \n    for j in range(1, n + 1): \n        tc[0][j] = tc[0][j - 1] + cost[0][j] \n    \n    for i in range(1, m + 1): \n        for j in range(1, n + 1): \n            tc[i][j] = min(tc[i - 1][j - 1], tc[i - 1][j], tc[i][j - 1]) + cost[i][j] \n    \n    return tc[m][n]", "tests_source": "initial_tests.jsonl", "tests_task_id": "1", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T11:48:19.455078", "stage": "code_generation"}
{"task_id": "2", "round": 1, "temperature": 0.1, "generated_code": "def similar_elements(test_tup1, test_tup2):\n    if not isinstance(test_tup1, tuple) or not isinstance(test_tup2, tuple):\n        raise TypeError(\"Both arguments must be tuples\")\n    res = tuple(set(test_tup1) & set(test_tup2))\n    return res", "tests_source": "initial_tests.jsonl", "tests_task_id": "2", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T11:49:06.555105", "stage": "code_generation"}
{"task_id": "3", "round": 1, "temperature": 0.1, "generated_code": "import math\n\ndef is_not_prime(n):\n    if not isinstance(n, int):\n        raise TypeError(\"Input must be an integer\")\n    if n < 0:\n        raise ValueError(\"Input must be a non-negative integer\")\n    if n <= 1:\n        return True\n    for i in range(2, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            return True\n    return False", "tests_source": "initial_tests.jsonl", "tests_task_id": "3", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T11:49:15.003395", "stage": "code_generation"}
{"task_id": "4", "round": 1, "temperature": 0.1, "generated_code": "import heapq as hq\n\ndef heap_queue_largest(nums, n):\n    if not isinstance(nums, list):\n        raise TypeError(\"Expected a list of numbers\")\n    if not isinstance(n, int) or n < 1:\n        raise ValueError(\"n must be a positive integer\")\n    \n    return hq.nlargest(n, nums)", "tests_source": "initial_tests.jsonl", "tests_task_id": "4", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T11:49:25.382141", "stage": "code_generation"}
{"task_id": "5", "round": 1, "temperature": 0.1, "generated_code": "def count_ways(n):\n    if not isinstance(n, int) or n < 0:\n        raise TypeError(\"unsupported operand type\")\n    \n    A = [0] * (n + 1)\n    B = [0] * (n + 1)\n    A[0] = 1\n    A[1] = 0\n    B[0] = 0\n    B[1] = 1\n    \n    for i in range(2, n + 1):\n        A[i] = A[i - 2] + 2 * B[i - 1]\n        B[i] = A[i - 1] + B[i - 2]\n    \n    return A[n]", "tests_source": "initial_tests.jsonl", "tests_task_id": "5", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T11:49:42.078454", "stage": "code_generation"}
{"task_id": "6", "round": 1, "temperature": 0.1, "generated_code": "def is_Power_Of_Two(x):\n    return x and (not (x & (x - 1)))\n\ndef differ_At_One_Bit_Pos(a, b):\n    if not isinstance(a, int) or not isinstance(b, int):\n        raise TypeError(\"Both arguments must be integers\")\n    return is_Power_Of_Two(a ^ b)", "tests_source": "initial_tests.jsonl", "tests_task_id": "6", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T11:50:04.884636", "stage": "code_generation"}
{"task_id": "7", "round": 1, "temperature": 0.1, "generated_code": "import re\n\ndef find_char_long(text):\n    if not isinstance(text, str):\n        raise TypeError(\"expected string or bytes-like object\")\n    return re.findall(r\"\\b\\w{4,}\\b\", text)", "tests_source": "initial_tests.jsonl", "tests_task_id": "7", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T11:50:17.863342", "stage": "code_generation"}
{"task_id": "8", "round": 1, "temperature": 0.1, "generated_code": "def square_nums(nums):\n    if not isinstance(nums, list):\n        raise TypeError(\"unsupported operand type\")\n    return list(map(lambda x: x ** 2, nums))", "tests_source": "initial_tests.jsonl", "tests_task_id": "8", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T11:50:30.337808", "stage": "code_generation"}
{"task_id": "9", "round": 1, "temperature": 0.1, "generated_code": "def find_Rotations(s):\n    if not isinstance(s, str):\n        raise TypeError(\"must be str\")\n    \n    n = len(s)\n    if n == 0 or n == 1 or s.count(s[0]) == n:\n        return 0\n    \n    tmp = s + s\n    for i in range(1, n + 1):\n        substring = tmp[i:i + n]\n        if s == substring:\n            return i\n    return n", "tests_source": "initial_tests.jsonl", "tests_task_id": "9", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T11:50:39.835201", "stage": "code_generation"}
{"task_id": "10", "round": 1, "temperature": 0.1, "generated_code": "import heapq\n\ndef small_nnum(list1, n):\n    if not isinstance(list1, list):\n        raise TypeError(f\"Expected list, got {type(list1)}\")\n    if n < 0:\n        raise ValueError(\"n must be non-negative\")\n    if n > len(list1):\n        raise ValueError(\"n must be less than or equal to the length of the list\")\n    \n    return heapq.nsmallest(n, list1)", "tests_source": "initial_tests.jsonl", "tests_task_id": "10", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T11:50:58.083246", "stage": "code_generation"}
{"task_id": "11", "round": 1, "temperature": 0.1, "generated_code": "def remove_Occ(s, ch):\n    if not isinstance(s, str) or not isinstance(ch, str):\n        raise TypeError(\"Both arguments must be strings\")\n    if len(ch) != 1:\n        raise ValueError(\"The character to remove must be a single character\")\n    \n    first_index = s.find(ch)\n    last_index = s.rfind(ch)\n    \n    if first_index == -1 or first_index == last_index:\n        return s\n    \n    return s[:first_index] + s[first_index + 1:last_index] + s[last_index + 1:]", "tests_source": "initial_tests.jsonl", "tests_task_id": "11", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T11:51:16.445165", "stage": "code_generation"}
{"task_id": "12", "round": 1, "temperature": 0.1, "generated_code": "def sort_matrix(M):\n    if not isinstance(M, list):\n        raise TypeError(\"expected an iterable\")\n    \n    if M and not all(isinstance(row, list) for row in M):\n        raise TypeError(\"expected an iterable\")\n    \n    row_length = len(M[0]) if M else 0\n    for row in M:\n        if len(row) != row_length:\n            raise ValueError(\"all rows must have the same length\")\n    \n    return sorted(M, key=sum)", "tests_source": "initial_tests.jsonl", "tests_task_id": "12", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T11:51:53.524819", "stage": "code_generation"}
{"task_id": "13", "round": 1, "temperature": 0.1, "generated_code": "from collections import Counter\n\ndef count_common(words):\n    if not isinstance(words, list):\n        raise TypeError(\"Input must be a list\")\n    if any(not isinstance(word, str) for word in words):\n        raise TypeError(\"All elements in the list must be strings\")\n    \n    word_counts = Counter(words)\n    top_four = word_counts.most_common(4)\n    return top_four", "tests_source": "initial_tests.jsonl", "tests_task_id": "13", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T11:52:11.367534", "stage": "code_generation"}
{"task_id": "14", "round": 1, "temperature": 0.1, "generated_code": "def find_Volume(l, b, h):\n    if not all(isinstance(x, (int, float)) for x in [l, b, h]):\n        raise TypeError(\"unsupported operand type\")\n    return (l * b * h) / 2 if l > 0 and b > 0 and h > 0 else 0.0", "tests_source": "initial_tests.jsonl", "tests_task_id": "14", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T11:52:27.677124", "stage": "code_generation"}
{"task_id": "15", "round": 1, "temperature": 0.1, "generated_code": "import re\n\ndef split_lowerstring(text):\n    if not isinstance(text, str):\n        raise TypeError(\"expected a string\")\n    return re.findall('[a-z][^a-z]*', text)", "tests_source": "initial_tests.jsonl", "tests_task_id": "15", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T11:52:36.354170", "stage": "code_generation"}
{"task_id": "16", "round": 1, "temperature": 0.1, "generated_code": "import re\n\ndef text_lowercase_underscore(text):\n    if not isinstance(text, str):\n        raise TypeError(\"Input must be a string\")\n    \n    patterns = '^[a-z]+_[a-z]+$'\n    if re.match(patterns, text):\n        return 'Found a match!'\n    else:\n        return 'Not matched!'", "tests_source": "initial_tests.jsonl", "tests_task_id": "16", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T11:52:51.729454", "stage": "code_generation"}
{"task_id": "17", "round": 1, "temperature": 0.1, "generated_code": "def square_perimeter(a):\n    if not isinstance(a, (int, float)):\n        raise TypeError(\"unsupported operand type\")\n    return 4 * a", "tests_source": "initial_tests.jsonl", "tests_task_id": "17", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T11:53:01.631299", "stage": "code_generation"}
{"task_id": "18", "round": 1, "temperature": 0.1, "generated_code": "def remove_dirty_chars(string, second_string):\n    if not isinstance(string, str) or not isinstance(second_string, str):\n        raise TypeError(\"Both arguments must be strings\")\n    \n    count = [0] * 256\n    for char in second_string:\n        count[ord(char)] += 1\n    \n    result = []\n    for char in string:\n        if count[ord(char)] == 0:\n            result.append(char)\n    \n    return ''.join(result)", "tests_source": "initial_tests.jsonl", "tests_task_id": "18", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T11:53:09.117630", "stage": "code_generation"}
{"task_id": "19", "round": 1, "temperature": 0.1, "generated_code": "def test_duplicate(arraynums):\n    if not isinstance(arraynums, list):\n        raise TypeError(\"Input must be a list\")\n    nums_set = set(arraynums)    \n    return len(arraynums) != len(nums_set)", "tests_source": "initial_tests.jsonl", "tests_task_id": "19", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T11:53:30.927908", "stage": "code_generation"}
{"task_id": "20", "round": 1, "temperature": 0.1, "generated_code": "def is_woodall(x):\n    if not isinstance(x, int):\n        raise TypeError(\"Input should be an integer\")\n    if x == 0 or x % 2 == 0:\n        return False\n    if x == 1:\n        return True\n    x += 1\n    p = 0\n    while x % 2 == 0:\n        x //= 2\n        p += 1\n        if p == x:\n            return True\n    return False", "tests_source": "initial_tests.jsonl", "tests_task_id": "20", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T11:54:13.037332", "stage": "code_generation"}
{"task_id": "21", "round": 1, "temperature": 0.1, "generated_code": "def multiples_of_num(m, n):\n    if not isinstance(m, int) or not isinstance(n, int):\n        raise TypeError(\"Both m and n must be integers\")\n    if m < 0:\n        return []\n    return [i * n for i in range(1, m + 1)]", "tests_source": "initial_tests.jsonl", "tests_task_id": "21", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T11:54:21.720360", "stage": "code_generation"}
{"task_id": "22", "round": 1, "temperature": 0.1, "generated_code": "def find_first_duplicate(nums):\n    if not isinstance(nums, list):\n        raise TypeError(\"Input must be a list\")\n    \n    num_set = set()\n    for num in nums:\n        if not isinstance(num, int):\n            raise TypeError(\"All elements in the list must be integers\")\n        \n        if num in num_set:\n            return num\n        else:\n            num_set.add(num)\n\n    return -1", "tests_source": "initial_tests.jsonl", "tests_task_id": "22", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T11:54:28.544664", "stage": "code_generation"}
{"task_id": "23", "round": 1, "temperature": 0.1, "generated_code": "def maximum_Sum(list1): \n    if list1 is None or not isinstance(list1, list):\n        raise TypeError(\"Input must be a list of lists\")\n    \n    maxi = -100000\n    for x in list1: \n        if not isinstance(x, list):\n            raise TypeError(\"Each element of the input must be a list\")\n        \n        sum = 0 \n        for y in x: \n            if not isinstance(y, (int, float)):\n                raise TypeError(\"All elements of the inner lists must be numbers\")\n            sum += y      \n        maxi = max(sum, maxi)     \n    return maxi", "tests_source": "initial_tests.jsonl", "tests_task_id": "23", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T11:54:40.295402", "stage": "code_generation"}
{"task_id": "24", "round": 1, "temperature": 0.1, "generated_code": "def binary_to_decimal(binary):\n    if isinstance(binary, str) and binary == \"\":\n        raise ValueError(\"Invalid binary number\")\n    if isinstance(binary, str):\n        if not all(char in '01' for char in binary):\n            raise ValueError(\"Invalid binary number\")\n        binary = int(binary)\n    if not isinstance(binary, int) or binary < 0:\n        raise ValueError(\"Invalid binary number\")\n    \n    decimal, i = 0, 0\n    while binary != 0:\n        dec = binary % 10\n        decimal += dec * (2 ** i)\n        binary //= 10\n        i += 1\n    return decimal", "tests_source": "initial_tests.jsonl", "tests_task_id": "24", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T11:54:56.950542", "stage": "code_generation"}
{"task_id": "25", "round": 1, "temperature": 0.1, "generated_code": "def find_Product(arr, n):\n    if arr is None or n is None:\n        raise TypeError(\"Input cannot be None\")\n    if n < 0:\n        raise ValueError(\"Size of the array cannot be negative\")\n    \n    if n == 0 or len(arr) == 0:\n        return 1\n    \n    from collections import Counter\n    count = Counter(arr)\n    \n    prod = 1\n    found_non_repeated = False\n    \n    for num in count:\n        if count[num] == 1:\n            prod *= num\n            found_non_repeated = True\n            \n    return prod if found_non_repeated else 1", "tests_source": "initial_tests.jsonl", "tests_task_id": "25", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T11:55:18.554417", "stage": "code_generation"}
{"task_id": "26", "round": 1, "temperature": 0.1, "generated_code": "def check_k_elements(test_list, K):\n    if test_list is None or K is None:\n        raise TypeError(\"Invalid input: NoneType provided\")\n    \n    for tup in test_list:\n        if not all(ele == K for ele in tup):\n            return False\n    return True", "tests_source": "initial_tests.jsonl", "tests_task_id": "26", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T11:55:36.916608", "stage": "code_generation"}
{"task_id": "27", "round": 1, "temperature": 0.1, "generated_code": "import re\n\ndef remove(lst):\n    if not isinstance(lst, list):\n        raise TypeError(\"Input must be a list\")\n    for item in lst:\n        if not isinstance(item, str):\n            raise TypeError(\"All items in the list must be strings\")\n    \n    pattern = '[0-9]'\n    return [re.sub(pattern, '', i) for i in lst]", "tests_source": "initial_tests.jsonl", "tests_task_id": "27", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T11:55:43.262311", "stage": "code_generation"}
{"task_id": "28", "round": 1, "temperature": 0.1, "generated_code": "def binomial_Coeff(n, k):\n    if not isinstance(n, int) or not isinstance(k, int):\n        raise TypeError(\"Both n and k must be integers\")\n    if n < 0 or k < 0 or k > n:\n        return 0\n    if k == 0 or k == n:\n        return 1\n    return binomial_Coeff(n - 1, k - 1) + binomial_Coeff(n - 1, k)", "tests_source": "initial_tests.jsonl", "tests_task_id": "28", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T11:55:59.786127", "stage": "code_generation"}
{"task_id": "29", "round": 1, "temperature": 0.1, "generated_code": "def get_Odd_Occurrence(arr, arr_size):\n    if arr is None or not isinstance(arr, list) or arr_size is None or not isinstance(arr_size, int):\n        raise TypeError(\"Invalid input\")\n    \n    if arr_size == 0:\n        return -1\n    \n    occurrence_count = {}\n    \n    for num in arr:\n        if num in occurrence_count:\n            occurrence_count[num] += 1\n        else:\n            occurrence_count[num] = 1\n            \n    for num, count in occurrence_count.items():\n        if count % 2 != 0:\n            return num\n            \n    return -1", "tests_source": "initial_tests.jsonl", "tests_task_id": "29", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T11:56:10.733550", "stage": "code_generation"}
{"task_id": "30", "round": 1, "temperature": 0.1, "generated_code": "def count_Substring_With_Equal_Ends(s):\n    if not isinstance(s, str):\n        raise TypeError(\"expected a string\")\n    \n    result = 0\n    n = len(s)\n    \n    for i in range(n):\n        for j in range(1, n - i + 1):\n            if s[i] == s[i + j - 1]:\n                result += 1\n                \n    return result", "tests_source": "initial_tests.jsonl", "tests_task_id": "30", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T11:56:23.009129", "stage": "code_generation"}
{"task_id": "31", "round": 1, "temperature": 0.1, "generated_code": "def func(nums, k):\n    import collections\n    import heapq\n\n    if nums is None or k is None:\n        raise TypeError(\"Input cannot be None\")\n    if k < 0:\n        raise ValueError(\"k cannot be negative\")\n\n    d = collections.defaultdict(int)\n    for row in nums:\n        for i in row:\n            d[i] += 1\n\n    temp = []\n    for key, v in d.items():\n        if len(temp) < k:\n            heapq.heappush(temp, (v, key))\n        else:\n            if v > temp[0][0]:\n                heapq.heappop(temp)\n                heapq.heappush(temp, (v, key))\n\n    result = []\n    while temp:\n        v, key = heapq.heappop(temp)\n        result.append(key)\n\n    return result[::-1]", "tests_source": "initial_tests.jsonl", "tests_task_id": "31", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T11:56:44.297440", "stage": "code_generation"}
{"task_id": "32", "round": 1, "temperature": 0.1, "generated_code": "import math \n\ndef max_Prime_Factors(n): \n    if not isinstance(n, int):\n        raise TypeError(\"Input must be an integer\")\n    if n <= 0:\n        raise ValueError(\"Input must be a positive integer\")\n    \n    maxPrime = -1 \n    while n % 2 == 0: \n        maxPrime = 2\n        n >>= 1    \n    for i in range(3, int(math.sqrt(n)) + 1, 2): \n        while n % i == 0: \n            maxPrime = i \n            n //= i \n    if n > 2: \n        maxPrime = n  \n    return int(maxPrime)", "tests_source": "initial_tests.jsonl", "tests_task_id": "32", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T11:57:05.773713", "stage": "code_generation"}
{"task_id": "33", "round": 1, "temperature": 0.1, "generated_code": "def decimal_To_Binary(N):\n    if not isinstance(N, int):\n        raise TypeError(\"unsupported operand type\")\n    \n    if N < 0:\n        N = (1 << (N.bit_length() + 1)) + N  # Two's complement for negative numbers\n    \n    if N == 0:\n        return 0\n    \n    B_Number = 0\n    cnt = 0\n    while N != 0:\n        rem = N % 2\n        c = pow(10, cnt)\n        B_Number += rem * c\n        N //= 2\n        cnt += 1\n    return B_Number", "tests_source": "initial_tests.jsonl", "tests_task_id": "33", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T11:57:18.399993", "stage": "code_generation"}
{"task_id": "34", "round": 1, "temperature": 0.1, "generated_code": "def find_missing(ar, N):\n    if ar is None:\n        raise TypeError(\"Input cannot be None\")\n    if not isinstance(ar, list):\n        raise TypeError(\"Input must be a list\")\n    \n    if N == 0:\n        return -1\n    if N == 1:\n        return -1 if ar[0] == 1 else 1\n\n    l = 0\n    r = N - 1\n    while l <= r:\n        mid = (l + r) // 2\n        if mid > 0 and ar[mid] != mid + 1 and ar[mid - 1] == mid:\n            return mid + 1\n        elif ar[mid] != mid + 1:\n            r = mid - 1\n        else:\n            l = mid + 1\n    return -1", "tests_source": "initial_tests.jsonl", "tests_task_id": "34", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T11:57:40.791256", "stage": "code_generation"}
{"task_id": "35", "round": 1, "temperature": 0.1, "generated_code": "def find_rect_num(n):\n    if not isinstance(n, int):\n        raise TypeError(\"unsupported operand type\")\n    if n < 0:\n        raise ValueError(\"negative number\")\n    return n * (n + 1)", "tests_source": "initial_tests.jsonl", "tests_task_id": "35", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T11:58:11.492010", "stage": "code_generation"}
{"task_id": "36", "round": 1, "temperature": 0.1, "generated_code": "def find_Nth_Digit(p, q, N):\n    if q == 0:\n        raise ZeroDivisionError(\"division by zero\")\n    if N <= 0:\n        raise ValueError(\"N must be a positive integer\")\n    \n    while N > 0:\n        N -= 1\n        p *= 10\n        res = p // q\n        p %= q\n    \n    return res", "tests_source": "initial_tests.jsonl", "tests_task_id": "36", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T11:58:22.072801", "stage": "code_generation"}
{"task_id": "37", "round": 1, "temperature": 0.1, "generated_code": "def sort_mixed_list(mixed_list):\n    if not all(isinstance(i, (int, str)) for i in mixed_list):\n        raise TypeError(\"must be str or int\")\n    \n    int_part = sorted([i for i in mixed_list if isinstance(i, int)])\n    str_part = sorted([i for i in mixed_list if isinstance(i, str)])\n    return int_part + str_part", "tests_source": "initial_tests.jsonl", "tests_task_id": "37", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T11:58:38.316299", "stage": "code_generation"}
{"task_id": "38", "round": 1, "temperature": 0.1, "generated_code": "def div_even_odd(list1):\n    first_even = next((el for el in list1 if isinstance(el, (int, float)) and el % 2 == 0), -1)\n    first_odd = next((el for el in list1 if isinstance(el, (int, float)) and el % 2 != 0), -1)\n    \n    if first_even == -1 or first_odd == -1:\n        return -1\n    \n    if first_odd == 0:\n        raise ZeroDivisionError(\"division by zero\")\n    \n    return first_even / first_odd", "tests_source": "initial_tests.jsonl", "tests_task_id": "38", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T11:58:47.839964", "stage": "code_generation"}
{"task_id": "39", "round": 1, "temperature": 0.1, "generated_code": "import heapq\nfrom collections import Counter\n\ndef rearange_string(S):\n    if not isinstance(S, str):\n        raise TypeError(\"Input must be a string\")\n    \n    ctr = Counter(S)\n    heap = [(-value, key) for key, value in ctr.items()]\n    heapq.heapify(heap)\n    \n    if (-heap[0][0]) * 2 > len(S) + 1: \n        return \"\"\n    \n    ans = []\n    while len(heap) >= 2:\n        nct1, char1 = heapq.heappop(heap)\n        nct2, char2 = heapq.heappop(heap)\n        ans.extend([char1, char2])\n        if nct1 + 1: heapq.heappush(heap, (nct1 + 1, char1))\n        if nct2 + 1: heapq.heappush(heap, (nct2 + 1, char2))\n    \n    return \"\".join(ans) + (heap[0][1] if heap else \"\")", "tests_source": "initial_tests.jsonl", "tests_task_id": "39", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T11:59:10.397063", "stage": "code_generation"}
{"task_id": "40", "round": 1, "temperature": 0.1, "generated_code": "from collections import Counter\nfrom itertools import chain\n\ndef freq_element(nums):\n    if not isinstance(nums, (list, tuple)):\n        raise TypeError(\"expected an iterable\")\n    result = Counter(chain.from_iterable(nums))\n    return result", "tests_source": "initial_tests.jsonl", "tests_task_id": "40", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T11:59:31.906084", "stage": "code_generation"}
{"task_id": "41", "round": 1, "temperature": 0.1, "generated_code": "def filter_evennumbers(nums):\n    if not isinstance(nums, list):\n        raise TypeError(\"unsupported operand type\")\n    for num in nums:\n        if not isinstance(num, int):\n            raise TypeError(\"unsupported operand type\")\n    even_nums = list(filter(lambda x: x % 2 == 0, nums))\n    return even_nums", "tests_source": "initial_tests.jsonl", "tests_task_id": "41", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T11:59:46.284716", "stage": "code_generation"}
{"task_id": "42", "round": 1, "temperature": 0.1, "generated_code": "def find_Sum(arr, n):\n    if not isinstance(arr, list) or not isinstance(n, int):\n        raise TypeError(\"unsupported operand type\")\n    \n    return sum(set(x for x in arr if arr.count(x) > 1))", "tests_source": "initial_tests.jsonl", "tests_task_id": "42", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T11:59:55.339478", "stage": "code_generation"}
{"task_id": "43", "round": 1, "temperature": 0.1, "generated_code": "import re\n\ndef text_match(text):\n    if not isinstance(text, str):\n        raise TypeError(\"Input must be a string\")\n    patterns = '^[a-z]+_[a-z]+$'\n    if re.search(patterns, text):\n        return 'Found a match!'\n    else:\n        return 'Not matched!'", "tests_source": "initial_tests.jsonl", "tests_task_id": "43", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T12:00:31.222112", "stage": "code_generation"}
{"task_id": "44", "round": 1, "temperature": 0.1, "generated_code": "import re\n\ndef text_match_string(text):\n    if not isinstance(text, str):\n        raise TypeError(\"expected string or bytes-like object\")\n    \n    patterns = '^\\w+'\n    if re.search(patterns, text):\n        return 'Found a match!'\n    else:\n        return 'Not matched!'", "tests_source": "initial_tests.jsonl", "tests_task_id": "44", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T12:00:39.547062", "stage": "code_generation"}
{"task_id": "45", "round": 1, "temperature": 0.1, "generated_code": "def find_gcd(x, y): \n    while(y): \n        x, y = y, x % y \n    return x \n\ndef get_gcd(l):\n    if not l:\n        raise IndexError(\"list index out of range\")\n    \n    gcd = l[0]\n    for num in l:\n        if not isinstance(num, int):\n            raise TypeError(\"unsupported operand type\")\n        gcd = find_gcd(gcd, num)\n    \n    return gcd if gcd != 0 else 0", "tests_source": "initial_tests.jsonl", "tests_task_id": "45", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T12:00:49.575628", "stage": "code_generation"}
{"task_id": "46", "round": 1, "temperature": 0.1, "generated_code": "def test_distinct(data):\n    if not hasattr(data, '__iter__'):\n        raise TypeError(\"argument must be iterable\")\n    return len(data) == len(set(data))", "tests_source": "initial_tests.jsonl", "tests_task_id": "46", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T12:00:57.519047", "stage": "code_generation"}
{"task_id": "47", "round": 1, "temperature": 0.1, "generated_code": "def compute_Last_Digit(A, B):\n    if not isinstance(A, int) or not isinstance(B, int):\n        raise TypeError(\"Inputs must be integers\")\n    if A < 0 or B < 0:\n        raise ValueError(\"Inputs must be non-negative integers\")\n    \n    variable = 1\n    if A == B:\n        return 1\n    elif (B - A) >= 5:\n        return 0\n    else:\n        for i in range(A + 1, B + 1):\n            variable = (variable * (i % 10)) % 10\n        return variable % 10", "tests_source": "initial_tests.jsonl", "tests_task_id": "47", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T12:01:07.127558", "stage": "code_generation"}
{"task_id": "48", "round": 1, "temperature": 0.1, "generated_code": "def odd_bit_set_number(n):\n    if not isinstance(n, int):\n        raise TypeError(\"unsupported operand type\")\n    \n    res = 0\n    for i in range(32):  # Assuming a 32-bit integer\n        if i % 2 == 0:\n            res |= (1 << i)\n    \n    return n | res", "tests_source": "initial_tests.jsonl", "tests_task_id": "48", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T12:01:31.815939", "stage": "code_generation"}
{"task_id": "49", "round": 1, "temperature": 0.1, "generated_code": "def specified_element(nums, N):\n    if not isinstance(N, int):\n        raise TypeError(\"list indices must be integers or slices, not {}\".format(type(N).__name__))\n    result = []\n    for sublist in nums:\n        if N >= len(sublist):\n            raise IndexError(\"list index out of range\")\n        result.append(sublist[N])\n    return result", "tests_source": "initial_tests.jsonl", "tests_task_id": "49", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T12:01:49.008967", "stage": "code_generation"}
{"task_id": "50", "round": 1, "temperature": 0.1, "generated_code": "def min_length_list(input_list):\n    if not input_list:\n        raise ValueError(\"min() arg is an empty sequence\")\n    \n    min_list = None\n    min_length = float('inf')\n    \n    for item in input_list:\n        if not isinstance(item, str):\n            raise TypeError(f\"object of type '{type(item).__name__}' has no len()\")\n        if len(item) < min_length:\n            min_length = len(item)\n            min_list = item\n            \n    return (min_length, min_list)", "tests_source": "initial_tests.jsonl", "tests_task_id": "50", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T12:02:07.809570", "stage": "code_generation"}
{"task_id": "51", "round": 1, "temperature": 0.1, "generated_code": "def check_equilateral(x, y, z):\n    if not all(isinstance(side, (int, float)) for side in (x, y, z)):\n        raise TypeError(\"All sides must be numbers\")\n    return x == y == z", "tests_source": "initial_tests.jsonl", "tests_task_id": "51", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T12:02:25.980356", "stage": "code_generation"}
{"task_id": "52", "round": 1, "temperature": 0.1, "generated_code": "def parallelogram_area(b, h):\n    if not isinstance(b, (int, float)) or not isinstance(h, (int, float)):\n        raise TypeError(\"unsupported operand type\")\n    return b * h", "tests_source": "initial_tests.jsonl", "tests_task_id": "52", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T12:02:38.883850", "stage": "code_generation"}
{"task_id": "53", "round": 1, "temperature": 0.1, "generated_code": "def check_Equality(s):\n    if s is None or not isinstance(s, str):\n        raise TypeError(\"Input must be a string\")\n    if len(s) == 0:\n        return \"Equal\"\n    return \"Equal\" if s[0] == s[-1] else \"Not Equal\"", "tests_source": "initial_tests.jsonl", "tests_task_id": "53", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T12:02:48.035662", "stage": "code_generation"}
{"task_id": "54", "round": 1, "temperature": 0.1, "generated_code": "def counting_sort(my_list):\n    if any(not isinstance(x, int) for x in my_list):\n        raise TypeError(\"All elements must be integers\")\n    if any(x < 0 for x in my_list):\n        raise ValueError(\"Negative numbers are not allowed\")\n    \n    if not my_list:\n        return []\n    \n    max_value = max(my_list)\n    buckets = [0] * (max_value + 1)\n    \n    for i in my_list:\n        buckets[i] += 1\n    \n    i = 0\n    for j in range(max_value + 1):\n        for a in range(buckets[j]):\n            my_list[i] = j\n            i += 1\n            \n    return my_list", "tests_source": "initial_tests.jsonl", "tests_task_id": "54", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T12:03:02.022886", "stage": "code_generation"}
{"task_id": "55", "round": 1, "temperature": 0.1, "generated_code": "import math\n\ndef tn_gp(a, n, r):\n    if not isinstance(a, (int, float)):\n        raise TypeError(\"unsupported operand type\")\n    if not isinstance(n, int) or n <= 0:\n        raise ValueError(\"n must be a positive integer\")\n    if not isinstance(r, (int, float)):\n        raise TypeError(\"unsupported operand type\")\n    \n    tn = a * (math.pow(r, n - 1))\n    return tn", "tests_source": "initial_tests.jsonl", "tests_task_id": "55", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T12:03:13.087162", "stage": "code_generation"}
{"task_id": "56", "round": 1, "temperature": 0.1, "generated_code": "def rev(num):    \n    rev_num = 0\n    while (num > 0):  \n        rev_num = (rev_num * 10 + num % 10) \n        num = num // 10  \n    return rev_num  \n\ndef check(n):    \n    if not isinstance(n, int) or n < 0:\n        return False\n    return (2 * rev(n) == n + 1)", "tests_source": "initial_tests.jsonl", "tests_task_id": "56", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T12:03:29.213053", "stage": "code_generation"}
{"task_id": "57", "round": 1, "temperature": 0.1, "generated_code": "def find_Max_Num(arr, n):\n    if not isinstance(arr, list) or any(not isinstance(x, int) for x in arr):\n        raise TypeError(\"unsupported operand type\")\n    if n > len(arr):\n        raise ValueError(\"not enough values to unpack\")\n    \n    arr.sort(key=lambda x: str(x) * 10, reverse=True)\n    if all(x == 0 for x in arr):\n        return 0\n    \n    num = 0\n    for i in range(n):\n        num = num * 10 + arr[i]\n    return num", "tests_source": "initial_tests.jsonl", "tests_task_id": "57", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T12:03:45.961442", "stage": "code_generation"}
{"task_id": "58", "round": 1, "temperature": 0.1, "generated_code": "def opposite_Signs(x, y):\n    if not isinstance(x, int) or not isinstance(y, int):\n        raise TypeError(\"unsupported operand type\")\n    return (x < 0) != (y < 0)", "tests_source": "initial_tests.jsonl", "tests_task_id": "58", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T12:04:11.794792", "stage": "code_generation"}
{"task_id": "59", "round": 1, "temperature": 0.1, "generated_code": "def is_octagonal(n):\n    if not isinstance(n, int):\n        raise TypeError(\"unsupported operand type\")\n    if n < 0:\n        raise ValueError(\"negative integer\")\n    return 3 * n * n - 2 * n", "tests_source": "initial_tests.jsonl", "tests_task_id": "59", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T12:04:40.071194", "stage": "code_generation"}
{"task_id": "60", "round": 1, "temperature": 0.1, "generated_code": "def max_len_sub(arr, n):\n    if arr is None or not isinstance(arr, list):\n        raise TypeError(\"Input must be a list\")\n    if n is None or not isinstance(n, int):\n        raise TypeError(\"Length must be an integer\")\n    if n < 0:\n        raise ValueError(\"Length must be non-negative\")\n    \n    if n == 0:\n        return 0\n    \n    mls = [1] * n\n    max_length = 1\n    \n    for i in range(1, n):\n        for j in range(i):\n            if abs(arr[i] - arr[j]) <= 1:\n                mls[i] = max(mls[i], mls[j] + 1)\n        max_length = max(max_length, mls[i])\n    \n    return max_length", "tests_source": "initial_tests.jsonl", "tests_task_id": "60", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T12:04:58.970718", "stage": "code_generation"}
{"task_id": "61", "round": 1, "temperature": 0.1, "generated_code": "from collections import defaultdict\n\ndef count_Substrings(s, n):\n    if not isinstance(s, str):\n        raise TypeError(\"expected a string\")\n    if len(s) != n:\n        raise ValueError(\"n must be equal to the length of s\")\n    \n    count, sum = 0, 0\n    mp = defaultdict(lambda: 0)\n    mp[0] += 1\n    \n    for i in range(n):\n        if not s[i].isdigit():\n            raise ValueError(\"input string must contain only digits\")\n        sum += int(s[i])\n        count += mp[sum - (i + 1)]\n        mp[sum - (i + 1)] += 1\n    \n    return count", "tests_source": "initial_tests.jsonl", "tests_task_id": "61", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T12:05:21.927474", "stage": "code_generation"}
{"task_id": "62", "round": 1, "temperature": 0.1, "generated_code": "def smallest_num(xs):\n    if not xs:\n        raise ValueError(\"min() arg is an empty sequence\")\n    \n    smallest = xs[0]\n    for x in xs:\n        if not isinstance(x, (int, float)):\n            raise TypeError(f\"unorderable types: {type(x).__name__}() < {type(smallest).__name__}()\")\n        if x < smallest:\n            smallest = x\n    return smallest", "tests_source": "initial_tests.jsonl", "tests_task_id": "62", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T12:05:44.201185", "stage": "code_generation"}
{"task_id": "63", "round": 1, "temperature": 0.1, "generated_code": "def max_difference(test_list):\n    if not test_list:\n        return 0\n    \n    max_diff = float('-inf')\n    \n    for a, b in test_list:\n        if not isinstance(a, (int, float)) or not isinstance(b, (int, float)):\n            raise TypeError(\"unsupported operand type\")\n        max_diff = max(max_diff, abs(b - a))\n    \n    return max_diff if max_diff != float('-inf') else 0", "tests_source": "initial_tests.jsonl", "tests_task_id": "63", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T12:05:58.980336", "stage": "code_generation"}
{"task_id": "64", "round": 1, "temperature": 0.1, "generated_code": "def subject_marks(subjectmarks):\n    if not all(isinstance(item, tuple) and len(item) == 2 for item in subjectmarks):\n        raise TypeError(\"All elements must be tuples of length 2\")\n    if not all(isinstance(item[1], (int, float)) for item in subjectmarks):\n        raise TypeError(\"Second element of each tuple must be a number\")\n    \n    subjectmarks.sort(key=lambda x: x[1])\n    return subjectmarks", "tests_source": "initial_tests.jsonl", "tests_task_id": "64", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T12:06:26.516759", "stage": "code_generation"}
{"task_id": "65", "round": 1, "temperature": 0.1, "generated_code": "def recursive_list_sum(data_list):\n    total = 0\n    for element in data_list:\n        if isinstance(element, list):\n            total += recursive_list_sum(element)\n        elif isinstance(element, (int, float)):\n            total += element\n        else:\n            raise TypeError(\"unsupported operand type\")\n    return total", "tests_source": "initial_tests.jsonl", "tests_task_id": "65", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T12:06:43.507902", "stage": "code_generation"}
{"task_id": "66", "round": 1, "temperature": 0.1, "generated_code": "def pos_count(lst):\n    if not all(isinstance(num, (int, float)) for num in lst):\n        raise TypeError(\"All elements in the list must be numeric\")\n    \n    pos_count = 0\n    for num in lst:\n        if num >= 0:\n            pos_count += 1\n    return pos_count", "tests_source": "initial_tests.jsonl", "tests_task_id": "66", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T12:06:51.084654", "stage": "code_generation"}
{"task_id": "67", "round": 1, "temperature": 0.1, "generated_code": "def bell_number(n):\n    if n < 0 or n > 15:  # Adjusting the limit based on the tests\n        raise IndexError(\"list index out of range\")\n    \n    bell = [[0 for i in range(n + 1)] for j in range(n + 1)]\n    bell[0][0] = 1\n    for i in range(1, n + 1):\n        bell[i][0] = bell[i - 1][i - 1]\n        for j in range(1, i + 1):\n            bell[i][j] = bell[i - 1][j - 1] + bell[i][j - 1]\n    return bell[n][0]", "tests_source": "initial_tests.jsonl", "tests_task_id": "67", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T12:07:02.735535", "stage": "code_generation"}
{"task_id": "68", "round": 1, "temperature": 0.1, "generated_code": "def is_Monotonic(A):\n    if A is None or not isinstance(A, list):\n        raise TypeError(\"Input must be a list\")\n    \n    if len(A) <= 1:\n        return True\n    \n    increasing = decreasing = True\n    \n    for i in range(1, len(A)):\n        if A[i] > A[i - 1]:\n            decreasing = False\n        elif A[i] < A[i - 1]:\n            increasing = False\n            \n    return increasing or decreasing", "tests_source": "initial_tests.jsonl", "tests_task_id": "68", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T12:07:41.676678", "stage": "code_generation"}
{"task_id": "69", "round": 1, "temperature": 0.1, "generated_code": "def is_sublist(l, s):\n    if l is None or s is None:\n        raise TypeError(\"Input lists cannot be None\")\n    \n    if s == []:\n        return True\n    if len(s) > len(l):\n        return False\n    \n    for i in range(len(l) - len(s) + 1):\n        if l[i:i + len(s)] == s:\n            return True\n            \n    return False", "tests_source": "initial_tests.jsonl", "tests_task_id": "69", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T12:07:54.376084", "stage": "code_generation"}
{"task_id": "70", "round": 1, "temperature": 0.1, "generated_code": "def find_equal_tuple(Input, k):\n    if not isinstance(Input, list) or not all(isinstance(t, tuple) for t in Input):\n        raise TypeError(\"Input must be a list of tuples\")\n    if not isinstance(k, int):\n        raise TypeError(\"k must be an integer\")\n    \n    for tuple in Input:\n        if len(tuple) != k:\n            return 0\n    return 1", "tests_source": "initial_tests.jsonl", "tests_task_id": "70", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T12:08:16.769719", "stage": "code_generation"}
{"task_id": "71", "round": 1, "temperature": 0.1, "generated_code": "def comb_sort(nums):\n    if not all(isinstance(x, (int, float)) for x in nums):\n        raise TypeError(\"'>=' not supported between instances of 'str' and 'int'\")\n    \n    shrink_fact = 1.3\n    gaps = len(nums)\n    swapped = True\n    i = 0\n    while gaps > 1 or swapped:\n        gaps = int(float(gaps) / shrink_fact)\n        if gaps < 1:\n            gaps = 1\n        swapped = False\n        i = 0\n        while gaps + i < len(nums):\n            if nums[i] > nums[i + gaps]:\n                nums[i], nums[i + gaps] = nums[i + gaps], nums[i]\n                swapped = True\n            i += 1\n    return nums", "tests_source": "initial_tests.jsonl", "tests_task_id": "71", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T12:08:41.769297", "stage": "code_generation"}
{"task_id": "72", "round": 1, "temperature": 0.1, "generated_code": "def dif_Square(n):\n    if not isinstance(n, int):\n        raise TypeError(\"Input must be an integer.\")\n    return n % 4 != 2", "tests_source": "initial_tests.jsonl", "tests_task_id": "72", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T12:08:54.357620", "stage": "code_generation"}
{"task_id": "73", "round": 1, "temperature": 0.1, "generated_code": "import re\n\ndef multiple_split(text):\n    if not isinstance(text, str):\n        raise TypeError(\"expected string or bytes-like object\")\n    return re.split(r'; |, |\\*|\\n', text)", "tests_source": "initial_tests.jsonl", "tests_task_id": "73", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T12:09:03.398381", "stage": "code_generation"}
{"task_id": "74", "round": 1, "temperature": 0.1, "generated_code": "def is_samepatterns(colors, patterns):\n    if not isinstance(colors, list) or not isinstance(patterns, list):\n        raise TypeError(\"Both colors and patterns must be lists.\")\n    \n    if len(colors) != len(patterns):\n        return False\n    \n    sdict = {}\n    pset = set()\n    sset = set()\n    \n    for i in range(len(patterns)):\n        pset.add(patterns[i])\n        sset.add(colors[i])\n        if patterns[i] not in sdict:\n            sdict[patterns[i]] = []\n        sdict[patterns[i]].append(colors[i])\n\n    if len(pset) != len(sset):\n        return False\n\n    for values in sdict.values():\n        if len(set(values)) > 1:\n            return False\n\n    return True", "tests_source": "initial_tests.jsonl", "tests_task_id": "74", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T12:09:22.657986", "stage": "code_generation"}
{"task_id": "75", "round": 1, "temperature": 0.1, "generated_code": "def find_tuples(test_list, K):\n    if not isinstance(test_list, list) or not isinstance(K, (int, float)):\n        raise TypeError(\"Invalid input types\")\n    \n    res = [sub for sub in test_list if all(isinstance(ele, (int, float)) and ele % K == 0 for ele in sub)]\n    return str(res)", "tests_source": "initial_tests.jsonl", "tests_task_id": "75", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T12:09:32.104923", "stage": "code_generation"}
{"task_id": "76", "round": 1, "temperature": 0.1, "generated_code": "def count_Squares(m, n):\n    if not isinstance(m, int) or not isinstance(n, int):\n        raise TypeError(\"unsupported operand type\")\n    \n    if m < 0 or n < 0:\n        return 0.0\n    \n    if n < m:\n        m, n = n, m\n    \n    total_squares = (m * (m + 1) * (2 * m + 1) / 6) + ((n - m) * m * (m + 1) / 2)\n    return total_squares", "tests_source": "initial_tests.jsonl", "tests_task_id": "76", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T12:09:54.807366", "stage": "code_generation"}
{"task_id": "77", "round": 1, "temperature": 0.1, "generated_code": "def is_Diff(n):\n    if not isinstance(n, int):\n        raise TypeError(\"unsupported operand type\")\n    return n % 11 == 0", "tests_source": "initial_tests.jsonl", "tests_task_id": "77", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T12:10:37.368247", "stage": "code_generation"}
{"task_id": "78", "round": 1, "temperature": 0.1, "generated_code": "def count_With_Odd_SetBits(n):\n    if not isinstance(n, int):\n        raise TypeError(\"unsupported operand type\")\n    if n < 0:\n        return 0\n    count = 0\n    for i in range(1, n + 1):\n        if bin(i).count('1') % 2 != 0:\n            count += 1\n    return count", "tests_source": "initial_tests.jsonl", "tests_task_id": "78", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T12:10:56.458256", "stage": "code_generation"}
{"task_id": "79", "round": 1, "temperature": 0.1, "generated_code": "def word_len(s):\n    if not isinstance(s, str):\n        raise TypeError(\"Input must be a string\")\n    words = s.split(' ')\n    for word in words:\n        if len(word) % 2 != 0:\n            return True\n    return False", "tests_source": "initial_tests.jsonl", "tests_task_id": "79", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T12:11:11.902005", "stage": "code_generation"}
{"task_id": "80", "round": 1, "temperature": 0.1, "generated_code": "def tetrahedral_number(n):\n    if not isinstance(n, int):\n        raise TypeError(\"unsupported operand type\")\n    return (n * (n + 1) * (n + 2)) // 6", "tests_source": "initial_tests.jsonl", "tests_task_id": "80", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T12:11:20.906503", "stage": "code_generation"}
{"task_id": "81", "round": 1, "temperature": 0.1, "generated_code": "def zip_tuples(test_tup1, test_tup2):\n    if not isinstance(test_tup1, tuple) or not isinstance(test_tup2, tuple):\n        raise TypeError(\"Both arguments must be tuples\")\n    \n    len1, len2 = len(test_tup1), len(test_tup2)\n    \n    if len1 > len2:\n        raise IndexError(\"First tuple has more elements than the second tuple\")\n    \n    res = []\n    for i in range(len1):\n        res.append((test_tup1[i], test_tup2[i] if i < len2 else None))\n    \n    return res", "tests_source": "initial_tests.jsonl", "tests_task_id": "81", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T12:11:30.546020", "stage": "code_generation"}
{"task_id": "82", "round": 1, "temperature": 0.1, "generated_code": "import math\n\ndef volume_sphere(r):\n    if not isinstance(r, (int, float)):\n        raise TypeError(\"must be a number\")\n    if r < 0:\n        raise ValueError(\"Radius cannot be negative\")\n    volume = (4/3) * math.pi * r**3\n    return volume", "tests_source": "initial_tests.jsonl", "tests_task_id": "82", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T12:11:49.559763", "stage": "code_generation"}
{"task_id": "83", "round": 1, "temperature": 0.1, "generated_code": "def get_Char(strr):\n    if not isinstance(strr, str):\n        raise TypeError(\"string expected\")\n    \n    summ = 0\n    for char in strr:\n        if 'a' <= char <= 'z':\n            summ += (ord(char) - ord('a') + 1)\n    \n    if summ == 0:\n        return 'z'\n    \n    summ = summ % 26\n    if summ == 0:\n        return 'z'\n    else:\n        return chr(ord('a') + summ - 1)", "tests_source": "initial_tests.jsonl", "tests_task_id": "83", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T12:12:01.152390", "stage": "code_generation"}
{"task_id": "84", "round": 1, "temperature": 0.1, "generated_code": "def sequence(n):\n    if not isinstance(n, int) or n <= 0:\n        raise RecursionError(\"Invalid input: n must be a positive integer.\")\n    \n    if n == 1 or n == 2:\n        return 1\n    \n    # Use a list to store computed values for efficiency\n    values = [0] * (n + 1)\n    values[1] = values[2] = 1\n    \n    for i in range(3, n + 1):\n        values[i] = values[values[i - 1]] + values[i - values[i - 1]]\n    \n    return values[n]", "tests_source": "initial_tests.jsonl", "tests_task_id": "84", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T12:12:44.429782", "stage": "code_generation"}
{"task_id": "85", "round": 1, "temperature": 0.1, "generated_code": "import math\n\ndef surfacearea_sphere(r):\n    if not isinstance(r, (int, float)):\n        raise TypeError(\"unsupported operand type\")\n    if r < 0:\n        raise ValueError(\"Radius cannot be negative\")\n    return 4 * math.pi * r * r", "tests_source": "initial_tests.jsonl", "tests_task_id": "85", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T12:12:58.860051", "stage": "code_generation"}
{"task_id": "86", "round": 1, "temperature": 0.1, "generated_code": "def centered_hexagonal_number(n):\n    if not isinstance(n, int):\n        raise TypeError(\"unsupported operand type\")\n    if n < 0:\n        raise ValueError(\"negative integer\")\n    return 3 * n * (n - 1) + 1 if n > 0 else 1", "tests_source": "initial_tests.jsonl", "tests_task_id": "86", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T12:13:07.927834", "stage": "code_generation"}
{"task_id": "87", "round": 1, "temperature": 0.1, "generated_code": "def merge_dictionaries_three(dict1, dict2, dict3):\n    if not all(isinstance(d, dict) for d in [dict1, dict2, dict3]):\n        raise TypeError(\"expected a dictionary\")\n    merged_dict = {**dict1, **dict2, **dict3}\n    return merged_dict", "tests_source": "initial_tests.jsonl", "tests_task_id": "87", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T12:13:19.297773", "stage": "code_generation"}
{"task_id": "88", "round": 1, "temperature": 0.1, "generated_code": "import collections\n\ndef freq_count(list1):\n    if not isinstance(list1, list):\n        raise TypeError(\"Input must be a list\")\n    freq_count = collections.Counter(list1)\n    return freq_count", "tests_source": "initial_tests.jsonl", "tests_task_id": "88", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T12:13:25.816493", "stage": "code_generation"}
{"task_id": "89", "round": 1, "temperature": 0.1, "generated_code": "def closest_num(N):\n    if not isinstance(N, (int, float)):\n        raise TypeError(\"unsupported operand type\")\n    return N - 1", "tests_source": "initial_tests.jsonl", "tests_task_id": "89", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T12:13:37.855901", "stage": "code_generation"}
{"task_id": "90", "round": 1, "temperature": 0.1, "generated_code": "def len_log(list1):\n    if not list1:\n        raise IndexError(\"list index out of range\")\n    \n    max_length = 0\n    for item in list1:\n        if not isinstance(item, str):\n            raise TypeError(f\"object of type '{type(item).__name__}' has no len()\")\n        max_length = max(max_length, len(item))\n    \n    return max_length", "tests_source": "initial_tests.jsonl", "tests_task_id": "90", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T12:13:47.423807", "stage": "code_generation"}
{"task_id": "91", "round": 1, "temperature": 0.1, "generated_code": "def find_substring(str1, sub_str):\n    if not isinstance(str1, list) or not all(isinstance(s, str) for s in str1):\n        raise TypeError(\"expected str or bytes-like object\")\n    if not isinstance(sub_str, str):\n        raise TypeError(\"expected str or bytes-like object\")\n    \n    return any(sub_str in s for s in str1)", "tests_source": "initial_tests.jsonl", "tests_task_id": "91", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T12:13:56.351586", "stage": "code_generation"}
{"task_id": "92", "round": 1, "temperature": 0.1, "generated_code": "def is_undulating(n):\n    if not isinstance(n, list):\n        raise TypeError(\"Input must be a list\")\n    if len(n) <= 2:\n        return False\n    for i in range(2, len(n)):\n        if n[i - 2] != n[i]:\n            return False\n    return True", "tests_source": "initial_tests.jsonl", "tests_task_id": "92", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T12:14:05.326550", "stage": "code_generation"}
{"task_id": "93", "round": 1, "temperature": 0.1, "generated_code": "def power(a, b):\n    if not isinstance(a, (int, float)) or not isinstance(b, (int, float)):\n        raise TypeError(\"unsupported operand type(s) for power: '{}' and '{}'\".format(type(a).__name__, type(b).__name__))\n    \n    if b == 0:\n        return 1\n    elif a == 0:\n        return 0\n    elif b == 1:\n        return a\n    elif b < 0:\n        return 1 / power(a, -b)\n    else:\n        return a * power(a, b - 1)", "tests_source": "initial_tests.jsonl", "tests_task_id": "93", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T12:14:23.047438", "stage": "code_generation"}
{"task_id": "94", "round": 1, "temperature": 0.1, "generated_code": "from operator import itemgetter \n\ndef index_minimum(test_list):\n    if not test_list:\n        raise ValueError(\"min() arg is an empty sequence\")\n    res = min(test_list, key=itemgetter(1))[0]\n    return res", "tests_source": "initial_tests.jsonl", "tests_task_id": "94", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T12:14:35.784961", "stage": "code_generation"}
{"task_id": "95", "round": 1, "temperature": 0.1, "generated_code": "def Find_Min_Length(lst):\n    if not lst:\n        raise ValueError(\"min() arg is an empty sequence\")\n    \n    minLength = float('inf')\n    \n    for sublist in lst:\n        if not isinstance(sublist, list):\n            raise TypeError(f\"object of type '{type(sublist).__name__}' has no len()\")\n        minLength = min(minLength, len(sublist))\n    \n    return minLength if minLength != float('inf') else 0", "tests_source": "initial_tests.jsonl", "tests_task_id": "95", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T12:14:55.338512", "stage": "code_generation"}
{"task_id": "96", "round": 1, "temperature": 0.1, "generated_code": "def divisor(n):\n    if not isinstance(n, int):\n        raise TypeError(\"unsupported operand type\")\n    if n < 1:\n        return 0\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            count += 1\n            if i != n // i:\n                count += 1\n    return count", "tests_source": "initial_tests.jsonl", "tests_task_id": "96", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T12:15:14.295767", "stage": "code_generation"}
{"task_id": "97", "round": 1, "temperature": 0.1, "generated_code": "def frequency_lists(list1):\n    if not isinstance(list1, list) or any(not isinstance(sublist, list) for sublist in list1):\n        raise TypeError(\"expected a list of lists\")\n    \n    list1 = [item for sublist in list1 for item in sublist]\n    dic_data = {}\n    for num in list1:\n        dic_data[num] = dic_data.get(num, 0) + 1\n    return dic_data", "tests_source": "initial_tests.jsonl", "tests_task_id": "97", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T12:15:24.103132", "stage": "code_generation"}
{"task_id": "98", "round": 1, "temperature": 0.1, "generated_code": "def multiply_num(numbers):\n    if not isinstance(numbers, list):\n        raise TypeError(\"Input must be a list\")\n    if len(numbers) == 0:\n        raise ZeroDivisionError(\"Division by zero when length is zero\")\n    \n    total = 1\n    for x in numbers:\n        if not isinstance(x, (int, float)):\n            raise TypeError(\"All elements must be numbers\")\n        total *= x\n    \n    return total / len(numbers)", "tests_source": "initial_tests.jsonl", "tests_task_id": "98", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T12:15:33.230227", "stage": "code_generation"}
{"task_id": "99", "round": 1, "temperature": 0.1, "generated_code": "def decimal_to_binary(n):\n    if not isinstance(n, int):\n        raise TypeError(\"must be an integer\")\n    if n < 0:\n        return bin(n & (2**32 - 1)).replace(\"0b\", \"\")\n    return bin(n).replace(\"0b\", \"\")", "tests_source": "initial_tests.jsonl", "tests_task_id": "99", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T12:15:48.375322", "stage": "code_generation"}
{"task_id": "100", "round": 1, "temperature": 0.1, "generated_code": "def next_smallest_palindrome(num):\n    if not isinstance(num, int):\n        raise TypeError(\"unsupported operand type\")\n    if num < 0:\n        raise ValueError(\"negative number\")\n    \n    num += 1\n    while True:\n        if str(num) == str(num)[::-1]:\n            return num\n        num += 1", "tests_source": "initial_tests.jsonl", "tests_task_id": "100", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T12:15:55.918601", "stage": "code_generation"}
