{"task_id": "1", "round": 3, "temperature": 0.1, "generated_code": "import pytest\n\nR = 3\nC = 3\n\ndef min_cost(cost, m, n): \n    if not cost or m < 0 or n < 0 or m >= len(cost) or n >= len(cost[0]):\n        raise IndexError(\"Invalid indices or empty matrix\")\n    \n    tc = [[0 for x in range(len(cost[0]))] for _ in range(len(cost))] \n    tc[0][0] = cost[0][0] \n    for i in range(1, m + 1): \n        tc[i][0] = tc[i - 1][0] + cost[i][0] \n    for j in range(1, n + 1): \n        tc[0][j] = tc[0][j - 1] + cost[0][j] \n    for i in range(1, m + 1): \n        for j in range(1, n + 1): \n            tc[i][j] = min(tc[i - 1][j], tc[i][j - 1], tc[i - 1][j - 1]) + cost[i][j] \n    return tc[m][n]\n\ndef test_basic_functionality():\n    cost_matrix = [[1, 2, 3], \n                   [4, 8, 2], \n                   [1, 5, 3]]\n    assert min_cost(cost_matrix, 2, 2) == 8, \"Should be 8\"\n\ndef test_another_basic_case():\n    cost_matrix = [[1, 3, 5], \n                   [2, 1, 2], \n                   [4, 3, 1]]\n    assert min_cost(cost_matrix, 2, 2) == 5, \"Should be 5\"\n\ndef test_edge_case_empty_matrix():\n    with pytest.raises(IndexError):\n        min_cost([], 0, 0)\n\ndef test_edge_case_single_element():\n    cost_matrix = [[5]]\n    assert min_cost(cost_matrix, 0, 0) == 5, \"Should be 5\"\n\ndef test_edge_case_large_matrix():\n    cost_matrix = [[1] * 100 for _ in range(100)]\n    assert min_cost(cost_matrix, 99, 99) == 198, \"Should be 198\"\n\ndef test_exceptions_invalid_indices():\n    cost_matrix = [[1, 2], [3, 4]]\n    with pytest.raises(IndexError):\n        min_cost(cost_matrix, 2, 2)\n\ndef test_exceptions_negative_indices():\n    cost_matrix = [[1, 2], [3, 4]]\n    with pytest.raises(IndexError):\n        min_cost(cost_matrix, -1, -1)", "tests_source": "initial_tests.jsonl", "tests_task_id": "1", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T15:14:53.520717", "stage": "code_repair"}
{"task_id": "4", "round": 3, "temperature": 0.1, "generated_code": "import heapq as hq\n\ndef heap_queue_largest(nums, n):\n    if not isinstance(nums, list):\n        raise TypeError(\"Expected a list of numbers\")\n    if not all(isinstance(x, (int, float)) for x in nums):\n        raise TypeError(\"Expected a list of numbers\")\n    if not isinstance(n, int) or n <= 0:\n        raise ValueError(\"n must be a positive integer\")\n    \n    largest_nums = hq.nlargest(n, nums)\n    return largest_nums", "tests_source": "initial_tests.jsonl", "tests_task_id": "4", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T15:15:40.681569", "stage": "code_repair"}
{"task_id": "7", "round": 3, "temperature": 0.1, "generated_code": "import re\n\ndef find_char_long(text):\n    if not isinstance(text, str):\n        raise TypeError(\"Input must be a string\")\n    return re.findall(r'\\b\\w{4,}\\b', text)", "tests_source": "initial_tests.jsonl", "tests_task_id": "7", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T15:16:31.612685", "stage": "code_repair"}
{"task_id": "9", "round": 3, "temperature": 0.1, "generated_code": "def find_Rotations(str): \n    if not isinstance(str, str):\n        raise TypeError(\"string expected\")\n    \n    n = len(str)\n    if n == 0:\n        return 0\n    \n    tmp = str + str\n    for i in range(1, n + 1): \n        substring = tmp[i: i+n] \n        if str == substring: \n            return i \n    return n", "tests_source": "initial_tests.jsonl", "tests_task_id": "9", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T15:16:56.698536", "stage": "code_repair"}
{"task_id": "10", "round": 3, "temperature": 0.1, "generated_code": "import heapq\n\ndef small_nnum(list1, n):\n    if not isinstance(list1, list):\n        raise TypeError(\"Expected list as first argument\")\n    if not isinstance(n, int):\n        raise TypeError(\"Expected integer for n\")\n    if n < 0:\n        raise ValueError(\"n must be non-negative\")\n    if n > len(list1):\n        n = len(list1)\n    \n    smallest = heapq.nsmallest(n, list1)\n    return smallest", "tests_source": "initial_tests.jsonl", "tests_task_id": "10", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T15:17:17.337159", "stage": "code_repair"}
{"task_id": "11", "round": 3, "temperature": 0.1, "generated_code": "def remove_Occ(s, ch): \n    if not isinstance(s, str) or not isinstance(ch, str) or len(ch) != 1:\n        raise TypeError(\"string indices must be integers\")\n    \n    first_index = s.find(ch)\n    last_index = s.rfind(ch)\n    \n    if first_index == -1 or first_index == last_index:\n        return s.replace(ch, \"\", 1) if first_index != -1 else s\n    \n    return s[:first_index] + s[first_index + 1:last_index] + s[last_index + 1:]\n\nimport pytest\n\ndef test_remove_first_and_last_occurrence_basic():\n    assert remove_Occ(\"hello world\", \"o\") == \"hell wrld\", \"Should remove first and last 'o'\"\n    assert remove_Occ(\"banana\", \"a\") == \"banan\", \"Should remove first and last 'a'\"\n\ndef test_remove_first_and_last_occurrence_no_occurrences():\n    assert remove_Occ(\"hello world\", \"x\") == \"hello world\", \"Should return the same string if character not found\"\n    assert remove_Occ(\"test string\", \"z\") == \"test string\", \"Should return the same string if character not found\"\n\ndef test_remove_first_and_last_occurrence_edge_cases():\n    assert remove_Occ(\"\", \"a\") == \"\", \"Should return empty string when input is empty\"\n    assert remove_Occ(\"a\", \"a\") == \"\", \"Should return empty string when input is a single character that matches\"\n    assert remove_Occ(\"aa\", \"a\") == \"\", \"Should return empty string when input is two characters that match\"\n    assert remove_Occ(\"abcabc\", \"a\") == \"bcab\", \"Should remove first and last 'a' from 'abcabc'\"\n\ndef test_remove_first_and_last_occurrence_multiple_occurrences():\n    assert remove_Occ(\"abracadabra\", \"a\") == \"bracadabr\", \"Should remove first and last 'a' from 'abracadabra'\"\n    assert remove_Occ(\"abababab\", \"b\") == \"ababab\", \"Should remove first and last 'b' from 'abababab'\"\n\ndef test_remove_first_and_last_occurrence_exceptions():\n    with pytest.raises(TypeError, match=\"string indices must be integers\"):\n        remove_Occ(None, \"a\")\n    with pytest.raises(TypeError, match=\"string indices must be integers\"):\n        remove_Occ(12345, \"1\")", "tests_source": "initial_tests.jsonl", "tests_task_id": "11", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T15:17:55.530454", "stage": "code_repair"}
{"task_id": "12", "round": 3, "temperature": 0.1, "generated_code": "def sort_matrix(M):\n    if not isinstance(M, list) or any(not isinstance(row, list) for row in M):\n        raise TypeError(\"expected matrix to be a list of lists\")\n    \n    for row in M:\n        if any(not isinstance(x, (int, float)) for x in row):\n            raise TypeError(\"unsupported operand type(s) for +: 'int' and 'str'\")\n    \n    result = sorted(M, key=sum)\n    return result", "tests_source": "initial_tests.jsonl", "tests_task_id": "12", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T15:18:12.639805", "stage": "code_repair"}
{"task_id": "13", "round": 3, "temperature": 0.1, "generated_code": "from collections import Counter\n\ndef count_common(words):\n    if not isinstance(words, list):\n        raise TypeError(\"Input must be a list\")\n    for word in words:\n        if not isinstance(word, str):\n            raise TypeError(\"All elements in the list must be strings\")\n    \n    word_counts = Counter(words)\n    top_four = word_counts.most_common(4)\n    return top_four\n\nimport pytest\n\ndef test_basic_functionality():\n    assert count_common(['apple', 'banana', 'apple', 'orange', 'banana', 'banana']) == [('banana', 3), ('apple', 2), ('orange', 1)]\n    assert count_common(['dog', 'cat', 'dog', 'cat', 'dog', 'fish']) == [('dog', 3), ('cat', 2), ('fish', 1)]\n    assert count_common(['hello', 'world', 'hello', 'hello']) == [('hello', 3), ('world', 1)]\n    assert count_common(['a', 'b', 'c', 'a', 'b', 'a']) == [('a', 3), ('b', 2), ('c', 1)]\n\ndef test_edge_cases():\n    assert count_common([]) == []\n    assert count_common(['single']) == [('single', 1)]\n    assert count_common(['same', 'same', 'same', 'same']) == [('same', 4)]\n\ndef test_exceptions():\n    with pytest.raises(TypeError):\n        count_common(None)\n    with pytest.raises(TypeError):\n        count_common(123)\n    with pytest.raises(TypeError):\n        count_common(['valid', 'input', 123])", "tests_source": "initial_tests.jsonl", "tests_task_id": "13", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T15:18:30.464490", "stage": "code_repair"}
{"task_id": "15", "round": 3, "temperature": 0.1, "generated_code": "import re\n\ndef split_lowerstring(text):\n    if not isinstance(text, str):\n        raise TypeError(\"expected a string\")\n    return re.findall('[a-z][^a-z]*', text)", "tests_source": "initial_tests.jsonl", "tests_task_id": "15", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T15:18:58.033427", "stage": "code_repair"}
{"task_id": "18", "round": 3, "temperature": 0.1, "generated_code": "NO_OF_CHARS = 256\n\ndef str_to_list(string): \n    temp = [] \n    for x in string: \n        temp.append(x) \n    return temp \n\ndef lst_to_string(List): \n    return ''.join(List) \n\ndef get_char_count_array(string): \n    count = [0] * NO_OF_CHARS \n    for i in string: \n        count[ord(i)] += 1\n    return count \n\ndef remove_dirty_chars(string, second_string): \n    if not isinstance(string, str) or not isinstance(second_string, str):\n        raise TypeError(\"Both arguments must be strings\")\n    \n    count = get_char_count_array(second_string) \n    ip_ind = 0\n    res_ind = 0\n    str_list = str_to_list(string) \n    while ip_ind != len(str_list): \n        temp = str_list[ip_ind] \n        if count[ord(temp)] == 0: \n            str_list[res_ind] = str_list[ip_ind] \n            res_ind += 1\n        ip_ind += 1\n    return lst_to_string(str_list[0:res_ind])", "tests_source": "initial_tests.jsonl", "tests_task_id": "18", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T15:19:40.307052", "stage": "code_repair"}
{"task_id": "23", "round": 3, "temperature": 0.1, "generated_code": "def maximum_Sum(list1): \n    if list1 == []:\n        return -100000\n    maxi = -100000\n    for x in list1: \n        if not isinstance(x, list):\n            raise TypeError(\"All elements must be lists\")\n        sum = 0 \n        for y in x: \n            if not isinstance(y, (int, float)):\n                raise TypeError(\"All elements must be numbers\")\n            sum += y      \n        maxi = max(sum, maxi)     \n    return maxi", "tests_source": "initial_tests.jsonl", "tests_task_id": "23", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T15:21:18.491840", "stage": "code_repair"}
{"task_id": "25", "round": 3, "temperature": 0.1, "generated_code": "def find_Product(arr, n): \n    if not isinstance(arr, list) or arr is None:\n        raise TypeError(\"unsupported operand type\")\n    if n != len(arr):\n        raise ValueError(\"not enough values to unpack\")\n    \n    from collections import Counter\n    count = Counter(arr)\n    prod = 1\n    found_non_repeated = False\n    \n    for num, freq in count.items():\n        if freq == 1:\n            prod *= num\n            found_non_repeated = True\n            \n    return prod if found_non_repeated else 1", "tests_source": "initial_tests.jsonl", "tests_task_id": "25", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T15:21:52.800646", "stage": "code_repair"}
{"task_id": "26", "round": 3, "temperature": 0.1, "generated_code": "def check_k_elements(test_list, K):\n    if not isinstance(test_list, list) or not all(isinstance(tup, tuple) for tup in test_list):\n        raise TypeError(\"First argument must be a list of tuples\")\n    if not isinstance(K, (int, float, str)):\n        raise TypeError(\"Second argument must be an int, float, or string\")\n    \n    res = True\n    for tup in test_list:\n        for ele in tup:\n            if ele != K:\n                res = False\n    return res", "tests_source": "initial_tests.jsonl", "tests_task_id": "26", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T15:22:12.661331", "stage": "code_repair"}
{"task_id": "30", "round": 3, "temperature": 0.1, "generated_code": "def check_Equality(s): \n    return (ord(s[0]) == ord(s[len(s) - 1])); \n\ndef count_Substring_With_Equal_Ends(s): \n    if not isinstance(s, str):\n        raise TypeError(\"expected a string\")\n    \n    result = 0; \n    n = len(s); \n    for i in range(n): \n        for j in range(1, n - i + 1):  \n            if (check_Equality(s[i:i+j])): \n                result += 1; \n    return result;", "tests_source": "initial_tests.jsonl", "tests_task_id": "30", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T15:23:14.464802", "stage": "code_repair"}
{"task_id": "31", "round": 3, "temperature": 0.1, "generated_code": "def func(nums, k):\n    import collections\n    import heapq\n\n    if nums is None or k is None:\n        raise TypeError(\"Input cannot be None\")\n    if k < 0:\n        raise ValueError(\"k cannot be negative\")\n\n    d = collections.defaultdict(int)\n    for row in nums:\n        for i in row:\n            d[i] += 1\n\n    temp = []\n    for key, v in d.items():\n        if len(temp) < k:\n            heapq.heappush(temp, (v, key))\n        else:\n            if v > temp[0][0]:\n                heapq.heappop(temp)\n                heapq.heappush(temp, (v, key))\n\n    result = []\n    while temp:\n        v, key = heapq.heappop(temp)\n        result.append(key)\n\n    return result[::-1]", "tests_source": "initial_tests.jsonl", "tests_task_id": "31", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T15:23:39.651531", "stage": "code_repair"}
{"task_id": "36", "round": 3, "temperature": 0.1, "generated_code": "def find_Nth_Digit(p, q, N):\n    if q == 0:\n        raise ZeroDivisionError(\"division by zero\")\n    if N <= 0:\n        raise ValueError(\"N must be a positive integer\")\n    \n    p = p % q  # Ensure p is within the bounds of q\n    while N > 0:\n        N -= 1\n        p *= 10\n        res = p // q\n        p %= q\n    return res", "tests_source": "initial_tests.jsonl", "tests_task_id": "36", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T15:24:52.816054", "stage": "code_repair"}
{"task_id": "38", "round": 3, "temperature": 0.1, "generated_code": "def div_even_odd(list1):\n    first_even = next((el for el in list1 if isinstance(el, int) and el % 2 == 0), -1)\n    first_odd = next((el for el in list1 if isinstance(el, int) and el % 2 != 0), -1)\n    \n    if first_even == -1 or first_odd == -1:\n        return -1\n    \n    if first_odd == 0:\n        raise ZeroDivisionError(\"division by zero\")\n    \n    return first_even / first_odd", "tests_source": "initial_tests.jsonl", "tests_task_id": "38", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T15:25:23.786217", "stage": "code_repair"}
{"task_id": "39", "round": 3, "temperature": 0.1, "generated_code": "import heapq\nfrom collections import Counter\n\ndef rearange_string(S):\n    if S is None or not isinstance(S, str):\n        raise TypeError(\"Input must be a string\")\n    \n    ctr = Counter(S)\n    heap = [(-value, key) for key, value in ctr.items()]\n    heapq.heapify(heap)\n    \n    if (-heap[0][0]) * 2 > len(S) + 1: \n        return \"\"\n    \n    ans = []\n    while len(heap) >= 2:\n        nct1, char1 = heapq.heappop(heap)\n        nct2, char2 = heapq.heappop(heap)\n        ans.extend([char1, char2])\n        if nct1 + 1: heapq.heappush(heap, (nct1 + 1, char1))\n        if nct2 + 1: heapq.heappush(heap, (nct2 + 1, char2))\n    \n    if heap:\n        ans.append(heap[0][1])\n    \n    return \"\".join(ans)", "tests_source": "initial_tests.jsonl", "tests_task_id": "39", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T15:25:49.094750", "stage": "code_repair"}
{"task_id": "40", "round": 3, "temperature": 0.1, "generated_code": "from collections import Counter\nfrom itertools import chain\n\ndef freq_element(nums):\n    if not isinstance(nums, (list, tuple)) or any(not isinstance(i, (list, tuple)) for i in nums):\n        raise TypeError(\"expected an iterable of iterables\")\n    result = Counter(chain.from_iterable(nums))\n    return result", "tests_source": "initial_tests.jsonl", "tests_task_id": "40", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T15:26:04.209781", "stage": "code_repair"}
{"task_id": "41", "round": 3, "temperature": 0.1, "generated_code": "def filter_evennumbers(nums):\n    if not isinstance(nums, list):\n        raise TypeError(\"Input must be a list\")\n    even_nums = list(filter(lambda x: isinstance(x, int) and x % 2 == 0, nums))\n    return even_nums", "tests_source": "initial_tests.jsonl", "tests_task_id": "41", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T15:26:16.498866", "stage": "code_repair"}
{"task_id": "42", "round": 3, "temperature": 0.1, "generated_code": "def find_Sum(arr, n):\n    if arr is None:\n        raise TypeError(\"unsupported operand type\")\n    if not isinstance(arr, list):\n        raise TypeError(\"unsupported operand type\")\n    \n    return sum(x for x in set(arr) if arr.count(x) > 1) * arr.count(x)", "tests_source": "initial_tests.jsonl", "tests_task_id": "42", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T15:26:37.469341", "stage": "code_repair"}
{"task_id": "47", "round": 3, "temperature": 0.1, "generated_code": "def compute_Last_Digit(A, B): \n    if not isinstance(A, int) or not isinstance(B, int):\n        raise TypeError(\"Inputs must be integers\")\n    if A < 0 or B < 0:\n        raise ValueError(\"Inputs must be non-negative integers\")\n    \n    variable = 1\n    if A == B: \n        return 1\n    elif (B - A) >= 5:  \n        return 0\n    else:   \n        for i in range(A + 1, B + 1): \n            variable = (variable * (i % 10)) % 10\n        return variable % 10", "tests_source": "initial_tests.jsonl", "tests_task_id": "47", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T15:27:42.735088", "stage": "code_repair"}
{"task_id": "48", "round": 3, "temperature": 0.1, "generated_code": "def odd_bit_set_number(n):\n    if not isinstance(n, int):\n        raise TypeError(\"unsupported operand type\")\n    \n    res = 0\n    for i in range(32):  # Assuming a 32-bit integer\n        if i % 2 == 1:  # Set odd bits\n            res |= (1 << i)\n    \n    return n | res", "tests_source": "initial_tests.jsonl", "tests_task_id": "48", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T15:28:10.985973", "stage": "code_repair"}
{"task_id": "49", "round": 3, "temperature": 0.1, "generated_code": "def specified_element(nums, N):\n    result = []\n    for i in nums:\n        if len(i) > N:\n            result.append(i[N])\n        else:\n            result.append(None)\n    return result", "tests_source": "initial_tests.jsonl", "tests_task_id": "49", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T15:28:26.767967", "stage": "code_repair"}
{"task_id": "50", "round": 3, "temperature": 0.1, "generated_code": "def min_length_list(input_list):\n    if not input_list:\n        raise ValueError(\"min() arg is an empty sequence\")\n    min_length = min(len(x) for x in input_list)  \n    min_list = min((x for x in input_list if isinstance(x, list)), key=lambda i: len(i))\n    return (min_length, min_list)", "tests_source": "initial_tests.jsonl", "tests_task_id": "50", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T15:28:43.065316", "stage": "code_repair"}
{"task_id": "55", "round": 3, "temperature": 0.1, "generated_code": "import math\n\ndef tn_gp(a, n, r):\n    if not isinstance(a, (int, float)):\n        raise TypeError(\"unsupported operand type\")\n    if not isinstance(n, int):\n        raise TypeError(\"unsupported operand type\")\n    if not isinstance(r, (int, float)):\n        raise TypeError(\"unsupported operand type\")\n    if n <= 0:\n        raise ValueError(\"n must be a positive integer\")\n    \n    tn = a * (math.pow(r, n - 1))\n    return tn", "tests_source": "initial_tests.jsonl", "tests_task_id": "55", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T15:29:42.304856", "stage": "code_repair"}
{"task_id": "56", "round": 3, "temperature": 0.1, "generated_code": "def rev(num):    \n    rev_num = 0\n    while (num > 0):  \n        rev_num = (rev_num * 10 + num % 10) \n        num = num // 10  \n    return rev_num  \n\ndef check(n):    \n    if not isinstance(n, int):\n        raise TypeError(\"Input must be an integer\")\n    return (2 * rev(n) == n + 1) and n >= 0", "tests_source": "initial_tests.jsonl", "tests_task_id": "56", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T15:30:03.030815", "stage": "code_repair"}
{"task_id": "58", "round": 3, "temperature": 0.1, "generated_code": "def opposite_Signs(x, y): \n    if not isinstance(x, int) or not isinstance(y, int):\n        raise TypeError(\"Both arguments must be integers.\")\n    return (x < 0) != (y < 0)\n\nimport pytest\n\ndef test_opposite_signs_positive_and_negative():\n    assert opposite_Signs(5, -3) is True, \"5 and -3 should have opposite signs\"\n    assert opposite_Signs(-5, 3) is True, \"-5 and 3 should have opposite signs\"\n\ndef test_opposite_signs_same_signs():\n    assert opposite_Signs(5, 3) is False, \"5 and 3 should not have opposite signs\"\n    assert opposite_Signs(-5, -3) is False, \"-5 and -3 should not have opposite signs\"\n\ndef test_opposite_signs_zero():\n    assert opposite_Signs(0, 5) is False, \"0 and 5 should not have opposite signs\"\n    assert opposite_Signs(0, -5) is False, \"0 and -5 should not have opposite signs\"\n    assert opposite_Signs(0, 0) is False, \"0 and 0 should not have opposite signs\"\n\ndef test_opposite_signs_large_numbers():\n    assert opposite_Signs(2**31 - 1, -2**31) is True, \"2**31 - 1 and -2**31 should have opposite signs\"\n    assert opposite_Signs(-2**31, 2**31 - 1) is True, \"-2**31 and 2**31 - 1 should have opposite signs\"\n\ndef test_opposite_signs_invalid_inputs():\n    with pytest.raises(TypeError):\n        opposite_Signs(\"a\", 5)\n    with pytest.raises(TypeError):\n        opposite_Signs(5, None)\n    with pytest.raises(TypeError):\n        opposite_Signs([], 5)", "tests_source": "initial_tests.jsonl", "tests_task_id": "58", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T15:30:46.225930", "stage": "code_repair"}
{"task_id": "59", "round": 3, "temperature": 0.1, "generated_code": "def is_octagonal(n): \n    if not isinstance(n, int):\n        raise TypeError(\"unsupported operand type\")\n    if n < 0:\n        raise ValueError(\"negative integer\")\n    return 3 * n * n - 2 * n", "tests_source": "initial_tests.jsonl", "tests_task_id": "59", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T15:31:00.425054", "stage": "code_repair"}
{"task_id": "61", "round": 3, "temperature": 0.1, "generated_code": "from collections import defaultdict\n\ndef count_Substrings(s, n):\n    if not isinstance(s, str) or not isinstance(n, int):\n        raise TypeError(\"string indices must be integers\")\n    if any(c not in '0123456789' for c in s):\n        raise ValueError(\"invalid literal for int() with base 10\")\n    \n    count, sum = 0, 0\n    mp = defaultdict(lambda: 0)\n    mp[0] += 1\n    \n    for i in range(n):\n        sum += ord(s[i]) - ord('0')\n        count += mp[sum - (i + 1)]\n        mp[sum - (i + 1)] += 1\n        \n    return count", "tests_source": "initial_tests.jsonl", "tests_task_id": "61", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T15:31:40.867542", "stage": "code_repair"}
{"task_id": "62", "round": 3, "temperature": 0.1, "generated_code": "def smallest_num(xs):\n    if not xs:\n        raise ValueError(\"min() arg is an empty sequence\")\n    return min(x for x in xs if x is not None)", "tests_source": "initial_tests.jsonl", "tests_task_id": "62", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T15:31:57.734523", "stage": "code_repair"}
{"task_id": "63", "round": 3, "temperature": 0.1, "generated_code": "def max_difference(test_list):\n    if not isinstance(test_list, list) or any(not isinstance(pair, tuple) or len(pair) != 2 for pair in test_list):\n        raise TypeError(\"Input must be a list of tuples with two elements each.\")\n    \n    temp = [abs(b - a) for a, b in test_list]\n    if not temp:\n        return 0\n    res = max(temp)\n    return res", "tests_source": "initial_tests.jsonl", "tests_task_id": "63", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T15:32:26.368500", "stage": "code_repair"}
{"task_id": "64", "round": 3, "temperature": 0.1, "generated_code": "def subject_marks(subjectmarks):\n    if not all(isinstance(item, tuple) and len(item) == 2 and isinstance(item[1], (int, float)) for item in subjectmarks):\n        raise TypeError(\"Invalid input type\")\n    subjectmarks.sort(key=lambda x: x[1])\n    return subjectmarks", "tests_source": "initial_tests.jsonl", "tests_task_id": "64", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T15:32:41.875499", "stage": "code_repair"}
{"task_id": "67", "round": 3, "temperature": 0.1, "generated_code": "def bell_number(n):   \n    if not isinstance(n, int) or n < 0:\n        raise TypeError(\"Input must be a non-negative integer\")\n    \n    bell = [[0 for i in range(n+1)] for j in range(n+1)] \n    bell[0][0] = 1\n    for i in range(1, n+1): \n        bell[i][0] = bell[i-1][i-1]  \n        for j in range(1, i+1): \n            bell[i][j] = bell[i-1][j-1] + bell[i][j-1]   \n    return bell[n][0] \n\nimport pytest\n\ndef test_bell_number_basic_cases():\n    assert bell_number(0) == 1, \"Bell number for n=0 should be 1\"\n    assert bell_number(1) == 1, \"Bell number for n=1 should be 1\"\n    assert bell_number(2) == 2, \"Bell number for n=2 should be 2\"\n    assert bell_number(3) == 5, \"Bell number for n=3 should be 5\"\n    assert bell_number(4) == 15, \"Bell number for n=4 should be 15\"\n\ndef test_bell_number_edge_cases():\n    assert bell_number(5) == 52, \"Bell number for n=5 should be 52\"\n    assert bell_number(6) == 203, \"Bell number for n=6 should be 203\"\n    assert bell_number(7) == 877, \"Bell number for n=7 should be 877\"\n\ndef test_bell_number_boundary_cases():\n    assert bell_number(10) == 115975, \"Bell number for n=10 should be 115975\"\n    assert bell_number(15) == 6513215599, \"Bell number for n=15 should be 6513215599\"\n\ndef test_bell_number_exceptions():\n    with pytest.raises(TypeError, match=\"Input must be a non-negative integer\"):\n        bell_number(-1)\n    with pytest.raises(TypeError, match=\"Input must be a non-negative integer\"):\n        bell_number(\"string\")\n    with pytest.raises(TypeError, match=\"Input must be a non-negative integer\"):\n        bell_number(None)", "tests_source": "initial_tests.jsonl", "tests_task_id": "67", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T15:33:46.612300", "stage": "code_repair"}
{"task_id": "69", "round": 3, "temperature": 0.1, "generated_code": "def is_sublist(l, s):\n    if l is None or s is None:\n        raise TypeError(\"Input lists cannot be None\")\n    \n    sub_set = False\n    if s == []:\n        sub_set = True\n    elif s == l:\n        sub_set = True\n    elif len(s) > len(l):\n        sub_set = False\n    else:\n        for i in range(len(l)):\n            if l[i] == s[0]:\n                n = 1\n                while (n < len(s)) and (i + n < len(l)) and (l[i + n] == s[n]):\n                    n += 1                \n                if n == len(s):\n                    sub_set = True\n    return sub_set", "tests_source": "initial_tests.jsonl", "tests_task_id": "69", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T15:34:27.433572", "stage": "code_repair"}
{"task_id": "70", "round": 3, "temperature": 0.1, "generated_code": "def find_equal_tuple(Input, k):\n    if not isinstance(Input, list) or not all(isinstance(t, tuple) for t in Input):\n        raise TypeError(\"Input must be a list of tuples\")\n    for tuple in Input:\n        if len(tuple) != k:\n            return 0\n    return 1\n\ndef get_equal(Input, k):\n    if find_equal_tuple(Input, k) == 1:\n        return (\"All tuples have same length\")\n    else:\n        return (\"All tuples do not have same length\")", "tests_source": "initial_tests.jsonl", "tests_task_id": "70", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T15:34:44.249112", "stage": "code_repair"}
{"task_id": "74", "round": 3, "temperature": 0.1, "generated_code": "def is_samepatterns(colors, patterns):    \n    if len(colors) != len(patterns):\n        return False    \n    sdict = {}\n    pset = set()\n    sset = set()    \n    for i in range(len(patterns)):\n        pset.add(patterns[i])\n        sset.add(colors[i])\n        if patterns[i] not in sdict:\n            sdict[patterns[i]] = colors[i]\n        elif sdict[patterns[i]] != colors[i]:\n            return False\n\n    return len(pset) == len(sset)\n\nimport pytest\n\ndef test_basic_functionality():\n    assert is_samepatterns(['red', 'blue', 'red'], ['A', 'B', 'A']) == True, \"Should match the pattern\"\n    assert is_samepatterns(['red', 'blue', 'green'], ['A', 'B', 'C']) == False, \"Should not match the pattern\"\n    assert is_samepatterns(['red', 'red', 'blue'], ['A', 'A', 'B']) == True, \"Should match the pattern\"\n    assert is_samepatterns(['green', 'green', 'green'], ['A', 'A', 'A']) == True, \"Should match the pattern\"\n    assert is_samepatterns(['yellow'], ['A']) == True, \"Single element should match\"\n\ndef test_edge_cases():\n    assert is_samepatterns([], []) == True, \"Empty inputs should match\"\n    assert is_samepatterns(['red'], []) == False, \"Different lengths should not match\"\n    assert is_samepatterns([], ['A']) == False, \"Different lengths should not match\"\n    assert is_samepatterns(['red', 'blue'], ['A', 'A']) == False, \"Different colors for same pattern should not match\"\n    assert is_samepatterns(['red', 'blue', 'red'], ['A', 'B', 'C']) == False, \"Should not match the pattern\"\n\ndef test_exceptions():\n    with pytest.raises(TypeError):\n        is_samepatterns(None, ['A', 'B', 'C'])\n    with pytest.raises(TypeError):\n        is_samepatterns(['red', 'blue', 'green'], None)\n    with pytest.raises(TypeError):\n        is_samepatterns(['red', 'blue'], 'not_a_list')\n    with pytest.raises(TypeError):\n        is_samepatterns('not_a_list', ['A', 'B'])\n\npytest.main()", "tests_source": "initial_tests.jsonl", "tests_task_id": "74", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T15:35:55.110366", "stage": "code_repair"}
{"task_id": "75", "round": 3, "temperature": 0.1, "generated_code": "def find_tuples(test_list, K):\n    if not isinstance(test_list, list) or not isinstance(K, int):\n        raise TypeError(\"Invalid input types\")\n    res = [sub for sub in test_list if all(isinstance(ele, int) and ele % K == 0 for ele in sub)]\n    return (str(res))", "tests_source": "initial_tests.jsonl", "tests_task_id": "75", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T15:36:12.191365", "stage": "code_repair"}
{"task_id": "76", "round": 3, "temperature": 0.1, "generated_code": "def count_Squares(m, n):\n    if not isinstance(m, int) or not isinstance(n, int):\n        raise TypeError(\"unsupported operand type\")\n    if m < 0 or n < 0:\n        return 0\n    if n < m:\n        temp = m\n        m = n\n        n = temp\n    return (m * (m + 1) * (2 * m + 1) // 6 + (n - m) * m * (m + 1) // 2)\n\nimport pytest\n\ndef test_basic_functionality():\n    assert count_Squares(2, 3) == pytest.approx(5.0, rel=1e-9), \"Should count 5 squares in a 2x3 rectangle\"\n    assert count_Squares(3, 3) == pytest.approx(14.0, rel=1e-9), \"Should count 14 squares in a 3x3 rectangle\"\n    assert count_Squares(1, 1) == pytest.approx(1.0, rel=1e-9), \"Should count 1 square in a 1x1 rectangle\"\n\ndef test_edge_cases():\n    assert count_Squares(0, 0) == pytest.approx(0.0, rel=1e-9), \"Should count 0 squares in a 0x0 rectangle\"\n    assert count_Squares(1, 0) == pytest.approx(0.0, rel=1e-9), \"Should count 0 squares in a 1x0 rectangle\"\n    assert count_Squares(0, 1) == pytest.approx(0.0, rel=1e-9), \"Should count 0 squares in a 0x1 rectangle\"\n    assert count_Squares(1, 1) == pytest.approx(1.0, rel=1e-9), \"Should count 1 square in a 1x1 rectangle\"\n\ndef test_exceptions():\n    with pytest.raises(TypeError, match=\"unsupported operand type\"):\n        count_Squares(\"a\", 3)\n    with pytest.raises(TypeError, match=\"unsupported operand type\"):\n        count_Squares(3, \"b\")\n    with pytest.raises(TypeError, match=\"unsupported operand type\"):\n        count_Squares(None, 3)\n    with pytest.raises(TypeError, match=\"unsupported operand type\"):\n        count_Squares(3, None)", "tests_source": "initial_tests.jsonl", "tests_task_id": "76", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T15:36:53.568597", "stage": "code_repair"}
{"task_id": "77", "round": 3, "temperature": 0.1, "generated_code": "def is_Diff(n):\n    if not isinstance(n, int):\n        raise TypeError(\"unsupported operand type\")\n    return (n % 11 == 0)\n\nimport pytest\n\ndef test_basic_functionality():\n    assert is_Diff(0) == True, \"Expected True for input 0\"\n    assert is_Diff(11) == True, \"Expected True for input 11\"\n    assert is_Diff(22) == True, \"Expected True for input 22\"\n    assert is_Diff(10) == False, \"Expected False for input 10\"\n    assert is_Diff(1) == False, \"Expected False for input 1\"\n\ndef test_edge_cases():\n    assert is_Diff(-11) == True, \"Expected True for input -11\"\n    assert is_Diff(-22) == True, \"Expected True for input -22\"\n    assert is_Diff(100) == False, \"Expected False for input 100\"\n    assert is_Diff(99999999999) == False, \"Expected False for large input\"\n\ndef test_exceptions():\n    with pytest.raises(TypeError, match=\"unsupported operand type\"):\n        is_Diff(\"string\")\n    with pytest.raises(TypeError, match=\"unsupported operand type\"):\n        is_Diff(None)\n    with pytest.raises(TypeError, match=\"unsupported operand type\"):\n        is_Diff([])\n\ndef test_negative_cases():\n    assert is_Diff(3) == False, \"Expected False for input 3\"\n    assert is_Diff(5) == False, \"Expected False for input 5\"\n    assert is_Diff(7) == False, \"Expected False for input 7\"", "tests_source": "initial_tests.jsonl", "tests_task_id": "77", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T15:37:18.688219", "stage": "code_repair"}
{"task_id": "78", "round": 3, "temperature": 0.1, "generated_code": "def count_With_Odd_SetBits(n): \n    if not isinstance(n, int):\n        raise TypeError(\"unsupported operand type\")\n    if n < 0:\n        return 0\n    count = 0\n    for i in range(n + 1):\n        if bin(i).count('1') % 2 != 0:\n            count += 1\n    return count", "tests_source": "initial_tests.jsonl", "tests_task_id": "78", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T15:37:40.030855", "stage": "code_repair"}
{"task_id": "81", "round": 3, "temperature": 0.1, "generated_code": "def zip_tuples(test_tup1, test_tup2):\n    if not isinstance(test_tup1, tuple) or not isinstance(test_tup2, tuple):\n        raise TypeError(\"Both inputs must be tuples.\")\n    \n    res = []\n    len_tup1 = len(test_tup1)\n    len_tup2 = len(test_tup2)\n\n    if len_tup1 == 0 and len_tup2 == 0:\n        return res\n\n    if len_tup1 == 0:\n        return [(None, test_tup2[i]) for i in range(len_tup2)]\n\n    if len_tup2 == 0:\n        return [(test_tup1[i], None) for i in range(len_tup1)]\n\n    if len_tup1 != len_tup2:\n        raise IndexError(\"The lengths of the tuples must match.\")\n\n    for i in range(len_tup1):\n        res.append((test_tup1[i], test_tup2[i]))\n\n    return res", "tests_source": "initial_tests.jsonl", "tests_task_id": "81", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T15:38:28.166785", "stage": "code_repair"}
{"task_id": "83", "round": 3, "temperature": 0.1, "generated_code": "def get_Char(strr):  \n    if not isinstance(strr, str):\n        raise TypeError(\"string expected\")\n    \n    summ = 0\n    for i in range(len(strr)): \n        summ += (ord(strr[i]) - ord('a') + 1)  \n    \n    if (summ % 26 == 0): \n        return 'z' \n    else: \n        summ = summ % 26\n        return chr(ord('a') + summ - 1)\n\nimport pytest\n\ndef test_basic_functionality():\n    assert get_Char(\"abc\") == 'c', \"Expected 'c' for input 'abc'\"\n    assert get_Char(\"xyz\") == 'a', \"Expected 'a' for input 'xyz'\"\n    assert get_Char(\"hello\") == 'o', \"Expected 'o' for input 'hello'\"\n    assert get_Char(\"test\") == 's', \"Expected 's' for input 'test'\"\n    assert get_Char(\"a\") == 'a', \"Expected 'a' for input 'a'\"\n\ndef test_edge_cases():\n    assert get_Char(\"\") == 'z', \"Expected 'z' for empty input\"\n    assert get_Char(\"z\") == 'z', \"Expected 'z' for input 'z'\"\n    assert get_Char(\"a\" * 25) == 'y', \"Expected 'y' for input of 25 'a's\"\n    assert get_Char(\"a\" * 26) == 'z', \"Expected 'z' for input of 26 'a's\"\n    assert get_Char(\"a\" * 27) == 'a', \"Expected 'a' for input of 27 'a's\"\n\ndef test_exceptions():\n    with pytest.raises(TypeError, match=\"string expected\"):\n        get_Char(123)\n    with pytest.raises(TypeError, match=\"string expected\"):\n        get_Char(None)\n    with pytest.raises(TypeError, match=\"string expected\"):\n        get_Char([\"a\", \"b\", \"c\"])", "tests_source": "initial_tests.jsonl", "tests_task_id": "83", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T15:39:10.561049", "stage": "code_repair"}
{"task_id": "84", "round": 3, "temperature": 0.1, "generated_code": "def sequence(n): \n    if not isinstance(n, int):\n        raise TypeError(\"must be an integer\")\n    if n <= 0:\n        raise ValueError(\"must be a positive integer\")\n    \n    if n == 1 or n == 2: \n        return 1\n    else: \n        seq = [0] * (n + 1)\n        seq[1], seq[2] = 1, 1\n        for i in range(3, n + 1):\n            seq[i] = seq[seq[i - 1]] + seq[i - seq[i - 1]]\n        return seq[n]", "tests_source": "initial_tests.jsonl", "tests_task_id": "84", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T15:39:34.875578", "stage": "code_repair"}
{"task_id": "86", "round": 3, "temperature": 0.1, "generated_code": "def centered_hexagonal_number(n):\n    if not isinstance(n, int):\n        raise TypeError(\"unsupported operand type\")\n    if n < 0:\n        raise ValueError(\"negative integer\")\n    return 3 * n * (n - 1) + 1 if n > 0 else 1\n\nimport pytest\n\ndef test_basic_functionality():\n    assert centered_hexagonal_number(1) == 1, \"Failed for n=1\"\n    assert centered_hexagonal_number(2) == 7, \"Failed for n=2\"\n    assert centered_hexagonal_number(3) == 19, \"Failed for n=3\"\n    assert centered_hexagonal_number(4) == 37, \"Failed for n=4\"\n    assert centered_hexagonal_number(5) == 61, \"Failed for n=5\"\n\ndef test_edge_cases():\n    assert centered_hexagonal_number(0) == 1, \"Failed for n=0 (should return 1)\"\n    assert centered_hexagonal_number(10) == 271, \"Failed for n=10\"\n    assert centered_hexagonal_number(100) == 29901, \"Failed for n=100\"\n\ndef test_exceptions():\n    with pytest.raises(TypeError, match=\"unsupported operand type\"):\n        centered_hexagonal_number(\"a\")\n    with pytest.raises(TypeError, match=\"unsupported operand type\"):\n        centered_hexagonal_number(None)\n    with pytest.raises(ValueError, match=\"negative integer\"):\n        centered_hexagonal_number(-1)", "tests_source": "initial_tests.jsonl", "tests_task_id": "86", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T15:40:10.532398", "stage": "code_repair"}
{"task_id": "88", "round": 3, "temperature": 0.1, "generated_code": "import collections\n\ndef freq_count(list1):\n    if list1 is None:\n        raise TypeError(\"Input cannot be None\")\n    for item in list1:\n        if not isinstance(item, (str, int, float)):\n            raise TypeError(\"All elements must be str, int, or float\")\n    freq_count = collections.Counter(list1)\n    return freq_count", "tests_source": "initial_tests.jsonl", "tests_task_id": "88", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T15:40:44.831568", "stage": "code_repair"}
{"task_id": "90", "round": 3, "temperature": 0.1, "generated_code": "def len_log(list1):\n    if not list1:\n        raise IndexError(\"list index out of range\")\n    \n    max_length = 0\n    for i in list1:\n        if not isinstance(i, str):\n            raise TypeError(f\"object of type '{type(i).__name__}' has no len()\")\n        if len(i) > max_length:\n            max_length = len(i)\n    return max_length", "tests_source": "initial_tests.jsonl", "tests_task_id": "90", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T15:41:11.344290", "stage": "code_repair"}
{"task_id": "92", "round": 3, "temperature": 0.1, "generated_code": "def is_undulating(n): \n    if not isinstance(n, list) or any(not isinstance(x, (int, float)) for x in n):\n        raise TypeError(\"Input must be a list of numbers\")\n    if len(n) <= 2: \n        return False\n    for i in range(2, len(n)): \n        if n[i - 2] != n[i]: \n            return False\n    return True", "tests_source": "initial_tests.jsonl", "tests_task_id": "92", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T15:41:38.864590", "stage": "code_repair"}
{"task_id": "93", "round": 3, "temperature": 0.1, "generated_code": "def power(a, b):\n    if not isinstance(a, (int, float)) or not isinstance(b, (int, float)):\n        raise TypeError(\"unsupported operand type\")\n    if b == 0:\n        return 1\n    elif a == 0:\n        return 0\n    elif b == 1:\n        return a\n    elif b < 0:\n        return 1 / power(a, -b)\n    else:\n        return a * power(a, b - 1)", "tests_source": "initial_tests.jsonl", "tests_task_id": "93", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T15:42:00.115621", "stage": "code_repair"}
{"task_id": "94", "round": 3, "temperature": 0.1, "generated_code": "from operator import itemgetter \n\ndef index_minimum(test_list):\n    if not isinstance(test_list, list):\n        raise TypeError(\"Input must be a list of tuples\")\n    if not test_list:\n        raise ValueError(\"min() arg is an empty sequence\")\n    \n    for item in test_list:\n        if not isinstance(item, tuple) or len(item) != 2:\n            raise TypeError(\"Each item in the list must be a tuple of length 2\")\n        if not isinstance(item[1], (int, float)):\n            raise TypeError(\"The second element of each tuple must be a number\")\n    \n    res = min(test_list, key=itemgetter(1))[0]\n    return res", "tests_source": "initial_tests.jsonl", "tests_task_id": "94", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T15:42:20.875505", "stage": "code_repair"}
{"task_id": "95", "round": 3, "temperature": 0.1, "generated_code": "def Find_Min_Length(lst):  \n    if not lst:\n        raise ValueError(\"min() arg is an empty sequence\")\n    \n    minLength = float('inf')\n    \n    for sublist in lst:\n        if not isinstance(sublist, list):\n            raise TypeError(f\"object of type '{type(sublist).__name__}' has no len()\")\n        minLength = min(minLength, len(sublist))\n    \n    return minLength if minLength != float('inf') else 0", "tests_source": "initial_tests.jsonl", "tests_task_id": "95", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T15:42:43.471095", "stage": "code_repair"}
{"task_id": "98", "round": 3, "temperature": 0.1, "generated_code": "import pytest\n\ndef multiply_num(numbers):  \n    if not isinstance(numbers, list):\n        raise TypeError(\"Input must be a list\")\n    if len(numbers) == 0:\n        raise ZeroDivisionError(\"Division by zero when length is zero\")\n    \n    total = 1\n    for x in numbers:\n        if not isinstance(x, (int, float)):\n            raise TypeError(\"All elements must be numbers\")\n        total *= x  \n    return total / len(numbers)\n\ndef test_basic_functionality():\n    assert multiply_num([1, 2, 3, 4]) == pytest.approx(6.0, rel=1e-9)\n    assert multiply_num([2, 5, 10]) == pytest.approx(10.0, rel=1e-9)\n    assert multiply_num([1, 1, 1, 1]) == pytest.approx(1.0, rel=1e-9)\n\ndef test_edge_cases():\n    assert multiply_num([0, 1, 2, 3]) == pytest.approx(0.0, rel=1e-9)\n    assert multiply_num([-1, -2, -3]) == pytest.approx(-2.0, rel=1e-9)\n    assert multiply_num([1, -1, 1, -1]) == pytest.approx(0.25, rel=1e-9)\n\ndef test_boundary_conditions():\n    with pytest.raises(ZeroDivisionError):\n        multiply_num([])  # Division by zero when length is zero\n    assert multiply_num([1]) == pytest.approx(1.0, rel=1e-9)\n    assert multiply_num([-1]) == pytest.approx(-1.0, rel=1e-9)\n\ndef test_exceptions():\n    with pytest.raises(ZeroDivisionError):\n        multiply_num([])  # Division by zero when length is zero\n    with pytest.raises(TypeError):\n        multiply_num(\"not a list\")  # Invalid input type\n    with pytest.raises(TypeError):\n        multiply_num([1, 2, \"three\"])  # Invalid element type", "tests_source": "initial_tests.jsonl", "tests_task_id": "98", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T15:43:45.510161", "stage": "code_repair"}
{"task_id": "99", "round": 3, "temperature": 0.1, "generated_code": "def decimal_to_binary(n): \n    if not isinstance(n, int):\n        raise TypeError(\"must be an integer\")\n    if n < 0:\n        n = (1 << (n.bit_length() + 1)) + n  # Convert to two's complement for negative numbers\n    return bin(n).replace(\"0b\",\"\")", "tests_source": "initial_tests.jsonl", "tests_task_id": "99", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T15:44:00.584766", "stage": "code_repair"}
