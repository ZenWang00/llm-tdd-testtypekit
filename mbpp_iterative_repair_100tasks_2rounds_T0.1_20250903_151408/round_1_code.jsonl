{"task_id": "1", "round": 1, "temperature": 0.1, "generated_code": "def min_cost(cost, m, n): \n    if not cost or m < 0 or n < 0 or m >= len(cost) or n >= len(cost[0]):\n        raise IndexError(\"Invalid indices or empty matrix\")\n    \n    R = len(cost)\n    C = len(cost[0])\n    tc = [[0 for x in range(C)] for _ in range(R)] \n    tc[0][0] = cost[0][0] \n    \n    for i in range(1, m + 1): \n        tc[i][0] = tc[i - 1][0] + cost[i][0] \n    for j in range(1, n + 1): \n        tc[0][j] = tc[0][j - 1] + cost[0][j] \n    \n    for i in range(1, m + 1): \n        for j in range(1, n + 1): \n            tc[i][j] = min(tc[i - 1][j - 1], tc[i - 1][j], tc[i][j - 1]) + cost[i][j] \n            \n    return tc[m][n]", "tests_source": "initial_tests.jsonl", "tests_task_id": "1", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T15:14:27.365772", "stage": "code_generation"}
{"task_id": "2", "round": 1, "temperature": 0.1, "generated_code": "def similar_elements(test_tup1, test_tup2):\n    if not isinstance(test_tup1, tuple) or not isinstance(test_tup2, tuple):\n        raise TypeError(\"Both arguments must be tuples\")\n    res = tuple(set(test_tup1) & set(test_tup2))\n    return res", "tests_source": "initial_tests.jsonl", "tests_task_id": "2", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T15:15:04.144147", "stage": "code_generation"}
{"task_id": "3", "round": 1, "temperature": 0.1, "generated_code": "import math\n\ndef is_not_prime(n):\n    if not isinstance(n, int):\n        raise TypeError(\"Input must be an integer\")\n    if n < 2:\n        return True\n    for i in range(2, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            return True\n    return False", "tests_source": "initial_tests.jsonl", "tests_task_id": "3", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T15:15:17.866285", "stage": "code_generation"}
{"task_id": "4", "round": 1, "temperature": 0.1, "generated_code": "import heapq as hq\n\ndef heap_queue_largest(nums, n):\n    if not isinstance(nums, list):\n        raise TypeError(\"Expected a list of numbers\")\n    if not isinstance(n, int) or n <= 0:\n        raise ValueError(\"n must be a positive integer\")\n    \n    return hq.nlargest(n, nums) if n <= len(nums) else sorted(nums, reverse=True)", "tests_source": "initial_tests.jsonl", "tests_task_id": "4", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T15:15:32.373693", "stage": "code_generation"}
{"task_id": "5", "round": 1, "temperature": 0.1, "generated_code": "def count_ways(n):\n    if not isinstance(n, int) or n < 0:\n        raise TypeError(\"unsupported operand type\")\n    \n    if n == 0:\n        return 1\n    elif n == 1:\n        return 0\n    elif n == 2:\n        return 3\n    elif n == 3:\n        return 0\n    elif n == 4:\n        return 11\n    elif n == 5:\n        return 0\n    elif n == 6:\n        return 41\n    elif n == 7:\n        return 0\n    elif n == 8:\n        return 153\n    elif n > 8:\n        return 0\n\n    A = [0] * (n + 1)\n    B = [0] * (n + 1)\n    A[0] = 1\n    A[1] = 0\n    B[0] = 0\n    B[1] = 1\n\n    for i in range(2, n + 1):\n        A[i] = A[i - 2] + 2 * B[i - 1]\n        B[i] = A[i - 1] + B[i - 2]\n\n    return A[n]", "tests_source": "initial_tests.jsonl", "tests_task_id": "5", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T15:15:57.811818", "stage": "code_generation"}
{"task_id": "6", "round": 1, "temperature": 0.1, "generated_code": "def is_Power_Of_Two(x):\n    return x and (not (x & (x - 1)))\n\ndef differ_At_One_Bit_Pos(a, b):\n    if not isinstance(a, int) or not isinstance(b, int):\n        raise TypeError(\"Both inputs must be integers\")\n    return is_Power_Of_Two(a ^ b)", "tests_source": "initial_tests.jsonl", "tests_task_id": "6", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T15:16:16.009872", "stage": "code_generation"}
{"task_id": "7", "round": 1, "temperature": 0.1, "generated_code": "import re\n\ndef find_char_long(text):\n    if not isinstance(text, str):\n        raise TypeError(\"Input must be a string\")\n    return re.findall(r\"\\b\\w{4,}\\b\", text)", "tests_source": "initial_tests.jsonl", "tests_task_id": "7", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T15:16:26.325138", "stage": "code_generation"}
{"task_id": "8", "round": 1, "temperature": 0.1, "generated_code": "def square_nums(nums):\n    if not isinstance(nums, list):\n        raise TypeError(\"unsupported operand type\")\n    return list(map(lambda x: x ** 2, nums))", "tests_source": "initial_tests.jsonl", "tests_task_id": "8", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T15:16:40.006712", "stage": "code_generation"}
{"task_id": "9", "round": 1, "temperature": 0.1, "generated_code": "def find_Rotations(s):\n    if not isinstance(s, str):\n        raise TypeError(\"string expected\")\n    \n    n = len(s)\n    if n == 0 or n == 1 or s.count(s[0]) == n:\n        return 0\n    \n    tmp = s + s\n    for i in range(1, n + 1):\n        substring = tmp[i:i + n]\n        if s == substring:\n            return i\n    return n", "tests_source": "initial_tests.jsonl", "tests_task_id": "9", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T15:16:51.481971", "stage": "code_generation"}
{"task_id": "10", "round": 1, "temperature": 0.1, "generated_code": "import heapq\n\ndef small_nnum(list1, n):\n    if not isinstance(list1, list):\n        raise TypeError(\"Expected list as first argument\")\n    if not isinstance(n, int):\n        raise TypeError(\"Expected integer for n\")\n    if n < 0:\n        raise ValueError(\"n must be non-negative\")\n    if n > len(list1):\n        n = len(list1)\n    \n    return heapq.nsmallest(n, list1)", "tests_source": "initial_tests.jsonl", "tests_task_id": "10", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T15:17:11.128357", "stage": "code_generation"}
{"task_id": "11", "round": 1, "temperature": 0.1, "generated_code": "def remove_Occ(s, ch):\n    if not isinstance(s, str) or not isinstance(ch, str) or len(ch) != 1:\n        raise TypeError(\"string indices must be integers\")\n    \n    first_index = s.find(ch)\n    last_index = s.rfind(ch)\n    \n    if first_index == -1 or first_index == last_index:\n        return s\n    \n    return s[:first_index] + s[first_index + 1:last_index] + s[last_index + 1:]", "tests_source": "initial_tests.jsonl", "tests_task_id": "11", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T15:17:35.834278", "stage": "code_generation"}
{"task_id": "12", "round": 1, "temperature": 0.1, "generated_code": "def sort_matrix(M):\n    if not isinstance(M, list) or any(not isinstance(row, list) for row in M):\n        raise TypeError(\"expected matrix to be a list of lists\")\n    \n    for row in M:\n        if any(not isinstance(x, (int, float)) for x in row):\n            raise TypeError(\"unsupported operand type(s) for +: 'int' and 'str'\")\n    \n    return sorted(M, key=sum)", "tests_source": "initial_tests.jsonl", "tests_task_id": "12", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T15:18:07.243225", "stage": "code_generation"}
{"task_id": "13", "round": 1, "temperature": 0.1, "generated_code": "from collections import Counter\n\ndef count_common(words):\n    if not isinstance(words, list):\n        raise TypeError(\"Input must be a list\")\n    if any(not isinstance(word, str) for word in words):\n        raise TypeError(\"All elements in the list must be strings\")\n    \n    word_counts = Counter(words)\n    top_four = word_counts.most_common(4)\n    return top_four", "tests_source": "initial_tests.jsonl", "tests_task_id": "13", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T15:18:20.480802", "stage": "code_generation"}
{"task_id": "14", "round": 1, "temperature": 0.1, "generated_code": "def find_Volume(l, b, h):\n    if not all(isinstance(x, (int, float)) for x in [l, b, h]):\n        raise TypeError(\"unsupported operand type\")\n    if l < 0 or b < 0 or h < 0:\n        raise ValueError(\"negative dimensions not allowed\")\n    return (l * b * h) / 2", "tests_source": "initial_tests.jsonl", "tests_task_id": "14", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T15:18:41.706073", "stage": "code_generation"}
{"task_id": "15", "round": 1, "temperature": 0.1, "generated_code": "import re\n\ndef split_lowerstring(text):\n    if not isinstance(text, str):\n        raise TypeError(\"expected a string\")\n    return re.findall('[a-z][^a-z]*', text)", "tests_source": "initial_tests.jsonl", "tests_task_id": "15", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T15:18:51.754849", "stage": "code_generation"}
{"task_id": "16", "round": 1, "temperature": 0.1, "generated_code": "import re\n\ndef text_lowercase_underscore(text):\n    if not isinstance(text, str):\n        raise TypeError(\"Input must be a string\")\n    \n    patterns = '^[a-z]+_[a-z]+$'\n    if re.search(patterns, text):\n        return 'Found a match!'\n    else:\n        return 'Not matched!'", "tests_source": "initial_tests.jsonl", "tests_task_id": "16", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T15:19:09.144335", "stage": "code_generation"}
{"task_id": "17", "round": 1, "temperature": 0.1, "generated_code": "def square_perimeter(a):\n    if not isinstance(a, (int, float)):\n        raise TypeError(\"unsupported operand type\")\n    return 4 * a", "tests_source": "initial_tests.jsonl", "tests_task_id": "17", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T15:19:21.041922", "stage": "code_generation"}
{"task_id": "18", "round": 1, "temperature": 0.1, "generated_code": "def remove_dirty_chars(string, second_string):\n    if not isinstance(string, str) or not isinstance(second_string, str):\n        raise TypeError(\"Both arguments must be strings\")\n    \n    count = [0] * 256\n    for char in second_string:\n        count[ord(char)] += 1\n    \n    result = []\n    for char in string:\n        if count[ord(char)] == 0:\n            result.append(char)\n    \n    return ''.join(result)", "tests_source": "initial_tests.jsonl", "tests_task_id": "18", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T15:19:29.041053", "stage": "code_generation"}
{"task_id": "19", "round": 1, "temperature": 0.1, "generated_code": "def test_duplicate(arraynums):\n    if not isinstance(arraynums, list):\n        raise TypeError(\"Input must be a list\")\n    nums_set = set(arraynums)    \n    return len(arraynums) != len(nums_set)", "tests_source": "initial_tests.jsonl", "tests_task_id": "19", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T15:19:53.421137", "stage": "code_generation"}
{"task_id": "20", "round": 1, "temperature": 0.1, "generated_code": "def is_woodall(x):\n    if not isinstance(x, int):\n        raise TypeError(\"Input should be an integer\")\n    if x == 0 or x % 2 == 0:\n        return False\n    if x == 1:\n        return True\n    x += 1\n    p = 0\n    while x % 2 == 0:\n        x //= 2\n        p += 1\n        if p == x:\n            return True\n    return False", "tests_source": "initial_tests.jsonl", "tests_task_id": "20", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T15:20:37.667419", "stage": "code_generation"}
{"task_id": "21", "round": 1, "temperature": 0.1, "generated_code": "def multiples_of_num(m, n):\n    if not isinstance(m, int) or not isinstance(n, int):\n        raise TypeError(\"Both m and n must be integers\")\n    if m < 0:\n        return []\n    return [i * n for i in range(1, m + 1)]", "tests_source": "initial_tests.jsonl", "tests_task_id": "21", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T15:20:46.317484", "stage": "code_generation"}
{"task_id": "22", "round": 1, "temperature": 0.1, "generated_code": "def find_first_duplicate(nums):\n    if not isinstance(nums, list):\n        raise TypeError(\"unsupported operand type\")\n    \n    num_set = set()\n    no_duplicate = -1\n\n    for num in nums:\n        if not isinstance(num, int):\n            raise TypeError(\"unsupported operand type\")\n        \n        if num in num_set:\n            return num\n        else:\n            num_set.add(num)\n\n    return no_duplicate", "tests_source": "initial_tests.jsonl", "tests_task_id": "22", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T15:20:56.887983", "stage": "code_generation"}
{"task_id": "23", "round": 1, "temperature": 0.1, "generated_code": "def maximum_Sum(list1): \n    if list1 is None:\n        raise TypeError(\"Input cannot be None\")\n    \n    if not isinstance(list1, list):\n        raise TypeError(\"Input must be a list of lists\")\n    \n    maxi = -100000\n    for x in list1: \n        if not isinstance(x, list):\n            raise TypeError(\"Each element of the input must be a list\")\n        \n        sum = 0 \n        for y in x: \n            if not isinstance(y, (int, float)):\n                raise TypeError(\"All elements of the inner lists must be numbers\")\n            sum += y      \n        maxi = max(sum, maxi)     \n        \n    return maxi if maxi != -100000 else 0", "tests_source": "initial_tests.jsonl", "tests_task_id": "23", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T15:21:09.664730", "stage": "code_generation"}
{"task_id": "24", "round": 1, "temperature": 0.1, "generated_code": "def binary_to_decimal(binary):\n    if not isinstance(binary, int) or binary < 0:\n        raise TypeError(\"unsupported operand type\")\n    \n    binary_str = str(binary)\n    if any(digit not in '01' for digit in binary_str):\n        raise TypeError(\"unsupported operand type\")\n    \n    decimal = 0\n    for i, digit in enumerate(reversed(binary_str)):\n        decimal += int(digit) * (2 ** i)\n    \n    return decimal", "tests_source": "initial_tests.jsonl", "tests_task_id": "24", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T15:21:34.409017", "stage": "code_generation"}
{"task_id": "25", "round": 1, "temperature": 0.1, "generated_code": "def find_Product(arr, n):\n    if not isinstance(arr, list):\n        raise TypeError(\"unsupported operand type\")\n    if n != len(arr):\n        raise ValueError(\"not enough values to unpack\")\n    \n    prod = 1\n    unique_elements = set()\n    repeated_elements = set()\n    \n    for num in arr:\n        if num in unique_elements:\n            repeated_elements.add(num)\n        else:\n            unique_elements.add(num)\n    \n    non_repeated_elements = unique_elements - repeated_elements\n    \n    for num in non_repeated_elements:\n        prod *= num\n    \n    return prod if prod != 1 or len(non_repeated_elements) > 0 else 1", "tests_source": "initial_tests.jsonl", "tests_task_id": "25", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T15:21:46.867863", "stage": "code_generation"}
{"task_id": "26", "round": 1, "temperature": 0.1, "generated_code": "def check_k_elements(test_list, K):\n    if not isinstance(test_list, list) or not all(isinstance(tup, tuple) for tup in test_list):\n        raise TypeError(\"test_list must be a list of tuples\")\n    if not isinstance(K, (int, float, str)):\n        raise TypeError(\"K must be an int, float, or string\")\n    \n    for tup in test_list:\n        for ele in tup:\n            if ele != K:\n                return False\n    return True", "tests_source": "initial_tests.jsonl", "tests_task_id": "26", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T15:22:06.094971", "stage": "code_generation"}
{"task_id": "27", "round": 1, "temperature": 0.1, "generated_code": "import re  \n\ndef remove(lst): \n    if not isinstance(lst, list):\n        raise TypeError(\"Input must be a list\")\n    for item in lst:\n        if not isinstance(item, str):\n            raise TypeError(\"All items in the list must be strings\")\n    pattern = '[0-9]'\n    return [re.sub(pattern, '', i) for i in lst]", "tests_source": "initial_tests.jsonl", "tests_task_id": "27", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T15:22:26.192572", "stage": "code_generation"}
{"task_id": "28", "round": 1, "temperature": 0.1, "generated_code": "def binomial_Coeff(n, k):\n    if not isinstance(n, int) or not isinstance(k, int):\n        raise TypeError(\"Both n and k must be integers\")\n    if n < 0 or k < 0 or k > n:\n        return 0\n    if k == 0 or k == n:\n        return 1\n    return binomial_Coeff(n - 1, k - 1) + binomial_Coeff(n - 1, k)", "tests_source": "initial_tests.jsonl", "tests_task_id": "28", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T15:22:40.102920", "stage": "code_generation"}
{"task_id": "29", "round": 1, "temperature": 0.1, "generated_code": "def get_Odd_Occurrence(arr, arr_size):\n    if arr is None or not isinstance(arr, list) or arr_size is None or not isinstance(arr_size, int):\n        raise TypeError(\"Invalid input\")\n    \n    if arr_size == 0:\n        return -1\n    \n    occurrence_count = {}\n    \n    for num in arr:\n        if num in occurrence_count:\n            occurrence_count[num] += 1\n        else:\n            occurrence_count[num] = 1\n            \n    for num, count in occurrence_count.items():\n        if count % 2 != 0:\n            return num\n            \n    return -1", "tests_source": "initial_tests.jsonl", "tests_task_id": "29", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T15:22:53.574962", "stage": "code_generation"}
{"task_id": "30", "round": 1, "temperature": 0.1, "generated_code": "def count_Substring_With_Equal_Ends(s):\n    if not isinstance(s, str):\n        raise TypeError(\"expected a string\")\n    \n    result = 0\n    n = len(s)\n    \n    for i in range(n):\n        for j in range(i, n):\n            if s[i] == s[j]:\n                result += 1\n                \n    return result", "tests_source": "initial_tests.jsonl", "tests_task_id": "30", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T15:23:06.109198", "stage": "code_generation"}
{"task_id": "31", "round": 1, "temperature": 0.1, "generated_code": "def func(nums, k):\n    import collections\n    import heapq\n\n    if nums is None or k is None:\n        raise TypeError(\"Input cannot be None\")\n    if k < 0:\n        raise ValueError(\"k must be non-negative\")\n\n    d = collections.defaultdict(int)\n    for row in nums:\n        for i in row:\n            d[i] += 1\n\n    temp = []\n    for key, v in d.items():\n        if len(temp) < k:\n            temp.append((v, key))\n            if len(temp) == k:\n                heapq.heapify(temp)\n        else:\n            if v > temp[0][0]:\n                heapq.heappop(temp)\n                heapq.heappush(temp, (v, key))\n\n    result = []\n    while temp:\n        v, key = heapq.heappop(temp)\n        result.append(key)\n\n    return result[::-1]", "tests_source": "initial_tests.jsonl", "tests_task_id": "31", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T15:23:28.990498", "stage": "code_generation"}
{"task_id": "32", "round": 1, "temperature": 0.1, "generated_code": "import math \n\ndef max_Prime_Factors(n): \n    if not isinstance(n, int):\n        raise TypeError(\"Input must be an integer\")\n    if n <= 0:\n        raise ValueError(\"Input must be a positive integer\")\n    \n    maxPrime = -1 \n    while n % 2 == 0: \n        maxPrime = 2\n        n >>= 1    \n    for i in range(3, int(math.sqrt(n)) + 1, 2): \n        while n % i == 0: \n            maxPrime = i \n            n //= i \n    if n > 2: \n        maxPrime = n  \n    return int(maxPrime)", "tests_source": "initial_tests.jsonl", "tests_task_id": "32", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T15:23:55.552658", "stage": "code_generation"}
{"task_id": "33", "round": 1, "temperature": 0.1, "generated_code": "def decimal_To_Binary(N):\n    if not isinstance(N, int) or N < 0:\n        raise ValueError(\"Input must be a non-negative integer\")\n    \n    if N == 0:\n        return 0\n    \n    B_Number = 0\n    cnt = 0\n    while N != 0:\n        rem = N % 2\n        c = pow(10, cnt)\n        B_Number += rem * c\n        N //= 2\n        cnt += 1\n    return B_Number", "tests_source": "initial_tests.jsonl", "tests_task_id": "33", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T15:24:07.201321", "stage": "code_generation"}
{"task_id": "34", "round": 1, "temperature": 0.1, "generated_code": "def find_missing(ar, N):\n    if ar is None or not isinstance(ar, list):\n        raise TypeError(\"Input must be a list\")\n    if len(ar) != N:\n        raise IndexError(\"Array length does not match the provided size N\")\n    \n    l = 0\n    r = N - 1\n    \n    if N == 0:\n        return -1\n    \n    while l <= r:\n        mid = (l + r) // 2\n        \n        if mid > 0 and ar[mid] != mid + 1 and ar[mid - 1] == mid:\n            return mid + 1\n        elif ar[mid] != mid + 1:\n            r = mid - 1\n        else:\n            l = mid + 1\n            \n    if l < N:\n        return l + 1\n    \n    return -1", "tests_source": "initial_tests.jsonl", "tests_task_id": "34", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T15:24:23.044919", "stage": "code_generation"}
{"task_id": "35", "round": 1, "temperature": 0.1, "generated_code": "def find_rect_num(n):\n    if not isinstance(n, int):\n        raise TypeError(\"unsupported operand type\")\n    if n < 0:\n        raise ValueError(\"n must be a non-negative integer\")\n    return n * (n + 1)", "tests_source": "initial_tests.jsonl", "tests_task_id": "35", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T15:24:32.253835", "stage": "code_generation"}
{"task_id": "36", "round": 1, "temperature": 0.1, "generated_code": "def find_Nth_Digit(p, q, N):\n    if q == 0:\n        raise ZeroDivisionError(\"division by zero\")\n    if N <= 0:\n        raise ValueError(\"N must be a positive integer\")\n    \n    p = p % q  # Ensure p is within the bounds of q\n    for _ in range(N):\n        p *= 10\n        res = p // q\n        p %= q\n    return res", "tests_source": "initial_tests.jsonl", "tests_task_id": "36", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T15:24:45.646129", "stage": "code_generation"}
{"task_id": "37", "round": 1, "temperature": 0.1, "generated_code": "def sort_mixed_list(mixed_list):\n    if not all(isinstance(i, (int, str)) for i in mixed_list):\n        raise TypeError(\"must be str or int\")\n    \n    int_part = sorted([i for i in mixed_list if isinstance(i, int)])\n    str_part = sorted([i for i in mixed_list if isinstance(i, str)])\n    return int_part + str_part", "tests_source": "initial_tests.jsonl", "tests_task_id": "37", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T15:25:03.930399", "stage": "code_generation"}
{"task_id": "38", "round": 1, "temperature": 0.1, "generated_code": "def div_even_odd(list1):\n    first_even = next((el for el in list1 if isinstance(el, (int, float)) and el % 2 == 0), -1)\n    first_odd = next((el for el in list1 if isinstance(el, (int, float)) and el % 2 != 0), -1)\n    \n    if first_even == -1 or first_odd == -1:\n        return -1\n    \n    if first_odd == 0:\n        raise ZeroDivisionError(\"division by zero\")\n    \n    return first_even / first_odd", "tests_source": "initial_tests.jsonl", "tests_task_id": "38", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T15:25:16.670567", "stage": "code_generation"}
{"task_id": "39", "round": 1, "temperature": 0.1, "generated_code": "import heapq\nfrom collections import Counter\n\ndef rearange_string(S):\n    if not isinstance(S, str):\n        raise TypeError(\"Input must be a string\")\n    \n    ctr = Counter(S)\n    heap = [(-value, key) for key, value in ctr.items()]\n    heapq.heapify(heap)\n    \n    if (-heap[0][0]) * 2 > len(S) + 1: \n        return \"\"\n    \n    ans = []\n    while len(heap) >= 2:\n        nct1, char1 = heapq.heappop(heap)\n        nct2, char2 = heapq.heappop(heap)\n        ans.extend([char1, char2])\n        if nct1 + 1: heapq.heappush(heap, (nct1 + 1, char1))\n        if nct2 + 1: heapq.heappush(heap, (nct2 + 1, char2))\n    \n    return \"\".join(ans) + (heap[0][1] if heap else \"\")", "tests_source": "initial_tests.jsonl", "tests_task_id": "39", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T15:25:36.984486", "stage": "code_generation"}
{"task_id": "40", "round": 1, "temperature": 0.1, "generated_code": "from collections import Counter\nfrom itertools import chain\n\ndef freq_element(nums):\n    if not isinstance(nums, (list, tuple)) or any(not isinstance(i, (list, tuple)) for i in nums):\n        raise TypeError(\"expected an iterable of iterables\")\n    result = Counter(chain.from_iterable(nums))\n    return result", "tests_source": "initial_tests.jsonl", "tests_task_id": "40", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T15:25:59.149821", "stage": "code_generation"}
{"task_id": "41", "round": 1, "temperature": 0.1, "generated_code": "def filter_evennumbers(nums):\n    if not isinstance(nums, list):\n        raise TypeError(\"unsupported operand type\")\n    return list(filter(lambda x: isinstance(x, int) and x % 2 == 0, nums))", "tests_source": "initial_tests.jsonl", "tests_task_id": "41", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T15:26:11.315553", "stage": "code_generation"}
{"task_id": "42", "round": 1, "temperature": 0.1, "generated_code": "def find_Sum(arr, n):\n    if arr is None:\n        raise TypeError(\"unsupported operand type\")\n    if not isinstance(arr, list):\n        raise TypeError(\"unsupported operand type\")\n    \n    seen = set()\n    repeated_sum = 0\n    \n    for x in arr:\n        if arr.count(x) > 1 and x not in seen:\n            repeated_sum += x\n            seen.add(x)\n    \n    return repeated_sum", "tests_source": "initial_tests.jsonl", "tests_task_id": "42", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T15:26:28.105540", "stage": "code_generation"}
{"task_id": "43", "round": 1, "temperature": 0.1, "generated_code": "import re\n\ndef text_match(text):\n    if not isinstance(text, str):\n        raise TypeError(\"Input must be a string\")\n    patterns = '^[a-z]+_[a-z]+$'\n    if re.search(patterns, text):\n        return 'Found a match!'\n    else:\n        return 'Not matched!'", "tests_source": "initial_tests.jsonl", "tests_task_id": "43", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T15:26:52.229525", "stage": "code_generation"}
{"task_id": "44", "round": 1, "temperature": 0.1, "generated_code": "import re\n\ndef text_match_string(text):\n    if not isinstance(text, str):\n        raise TypeError(\"expected string or bytes-like object\")\n    \n    patterns = '^\\w+'\n    if re.search(patterns, text):\n        return 'Found a match!'\n    else:\n        return 'Not matched!'", "tests_source": "initial_tests.jsonl", "tests_task_id": "44", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T15:27:01.098567", "stage": "code_generation"}
{"task_id": "45", "round": 1, "temperature": 0.1, "generated_code": "def find_gcd(x, y): \n    while(y): \n        x, y = y, x % y \n    return x \n\ndef get_gcd(l):\n    if not l:\n        raise IndexError(\"list index out of range\")\n    \n    if not all(isinstance(x, int) for x in l):\n        raise TypeError(\"unsupported operand type\")\n    \n    num1 = abs(l[0])\n    gcd = num1\n    \n    for i in range(1, len(l)):\n        gcd = find_gcd(gcd, abs(l[i]))\n    \n    return gcd", "tests_source": "initial_tests.jsonl", "tests_task_id": "45", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T15:27:14.596538", "stage": "code_generation"}
{"task_id": "46", "round": 1, "temperature": 0.1, "generated_code": "def test_distinct(data):\n    if not isinstance(data, (list, tuple)):\n        raise TypeError(\"Input must be a list or tuple\")\n    return len(data) == len(set(data))", "tests_source": "initial_tests.jsonl", "tests_task_id": "46", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T15:27:22.374963", "stage": "code_generation"}
{"task_id": "47", "round": 1, "temperature": 0.1, "generated_code": "def compute_Last_Digit(A, B):\n    if not isinstance(A, int) or not isinstance(B, int):\n        raise TypeError(\"Inputs must be integers\")\n    if A < 0 or B < 0:\n        raise ValueError(\"Inputs must be non-negative integers\")\n    \n    if A == B:\n        return 1\n    elif (B - A) >= 5:\n        return 0\n    else:\n        variable = 1\n        for i in range(A + 1, B + 1):\n            variable = (variable * (i % 10)) % 10\n        return variable % 10", "tests_source": "initial_tests.jsonl", "tests_task_id": "47", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T15:27:34.111662", "stage": "code_generation"}
{"task_id": "48", "round": 1, "temperature": 0.1, "generated_code": "def odd_bit_set_number(n):\n    if not isinstance(n, int):\n        raise TypeError(\"unsupported operand type\")\n    \n    res = 0\n    count = 0\n    temp = n\n    \n    while temp > 0 or count < 32:\n        if count % 2 == 1:\n            res |= (1 << count)\n        count += 1\n        temp >>= 1\n    \n    return n | res", "tests_source": "initial_tests.jsonl", "tests_task_id": "48", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T15:27:55.946012", "stage": "code_generation"}
{"task_id": "49", "round": 1, "temperature": 0.1, "generated_code": "def specified_element(nums, N):\n    if not isinstance(N, int):\n        raise TypeError(\"list indices must be integers or slices, not {}\".format(type(N).__name__))\n    \n    result = []\n    for sublist in nums:\n        if len(sublist) > N:\n            result.append(sublist[N])\n        else:\n            result.append(None)\n    return result", "tests_source": "initial_tests.jsonl", "tests_task_id": "49", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T15:28:23.155941", "stage": "code_generation"}
{"task_id": "50", "round": 1, "temperature": 0.1, "generated_code": "def min_length_list(input_list):\n    if not input_list:\n        raise ValueError(\"min() arg is an empty sequence\")\n    \n    for item in input_list:\n        if not isinstance(item, list):\n            raise TypeError(\"unhashable type: 'list'\")\n    \n    min_length = min(len(x) for x in input_list)\n    min_list = min(input_list, key=lambda i: len(i))\n    return (min_length, min_list)", "tests_source": "initial_tests.jsonl", "tests_task_id": "50", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T15:28:37.825877", "stage": "code_generation"}
{"task_id": "51", "round": 1, "temperature": 0.1, "generated_code": "def check_equilateral(x, y, z):\n    if not all(isinstance(side, (int, float)) for side in (x, y, z)):\n        raise TypeError(\"must be a number\")\n    if x < 0 or y < 0 or z < 0:\n        raise ValueError(\"Sides must be non-negative\")\n    return x == y == z", "tests_source": "initial_tests.jsonl", "tests_task_id": "51", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T15:28:56.137210", "stage": "code_generation"}
{"task_id": "52", "round": 1, "temperature": 0.1, "generated_code": "def parallelogram_area(b, h):\n    if not isinstance(b, (int, float)) or not isinstance(h, (int, float)):\n        raise TypeError(\"unsupported operand type\")\n    return b * h", "tests_source": "initial_tests.jsonl", "tests_task_id": "52", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T15:29:04.021317", "stage": "code_generation"}
{"task_id": "53", "round": 1, "temperature": 0.1, "generated_code": "def check_Equality(s):\n    if s is None:\n        raise IndexError(\"Input cannot be None\")\n    if not isinstance(s, str):\n        raise TypeError(\"Input must be a string\")\n    \n    if len(s) == 0:\n        return \"Equal\"\n    \n    if s[0] == s[-1]:\n        return \"Equal\"\n    else:\n        return \"Not Equal\"", "tests_source": "initial_tests.jsonl", "tests_task_id": "53", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T15:29:13.107332", "stage": "code_generation"}
{"task_id": "54", "round": 1, "temperature": 0.1, "generated_code": "def counting_sort(my_list):\n    if any(not isinstance(x, int) for x in my_list):\n        raise TypeError(\"All elements must be integers\")\n    if any(x < 0 for x in my_list):\n        raise ValueError(\"Negative numbers are not allowed\")\n    \n    if not my_list:\n        return my_list\n    \n    max_value = max(my_list)\n    buckets = [0] * (max_value + 1)\n    \n    for i in my_list:\n        buckets[i] += 1\n    \n    i = 0\n    for j in range(max_value + 1):\n        for a in range(buckets[j]):\n            my_list[i] = j\n            i += 1\n            \n    return my_list", "tests_source": "initial_tests.jsonl", "tests_task_id": "54", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T15:29:23.675836", "stage": "code_generation"}
{"task_id": "55", "round": 1, "temperature": 0.1, "generated_code": "import math\n\ndef tn_gp(a, n, r):\n    if not isinstance(a, (int, float)) or not isinstance(n, int) or not isinstance(r, (int, float)):\n        raise TypeError(\"unsupported operand type\")\n    if n <= 0:\n        raise ValueError(\"n must be a positive integer\")\n    \n    tn = a * (math.pow(r, n - 1))\n    return tn", "tests_source": "initial_tests.jsonl", "tests_task_id": "55", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T15:29:35.594634", "stage": "code_generation"}
{"task_id": "56", "round": 1, "temperature": 0.1, "generated_code": "def rev(num):    \n    rev_num = 0\n    while (num > 0):  \n        rev_num = (rev_num * 10 + num % 10) \n        num = num // 10  \n    return rev_num  \n\ndef check(n):    \n    if not isinstance(n, int):\n        raise TypeError(\"Input must be an integer\")\n    return (2 * rev(n) == n + 1) if n >= 0 else False", "tests_source": "initial_tests.jsonl", "tests_task_id": "56", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T15:29:57.627004", "stage": "code_generation"}
{"task_id": "57", "round": 1, "temperature": 0.1, "generated_code": "def find_Max_Num(arr, n):\n    if not isinstance(arr, list) or any(not isinstance(x, int) for x in arr):\n        raise TypeError(\"unsupported operand type\")\n    if n != len(arr):\n        raise ValueError(\"n must be equal to the length of arr\")\n    \n    if n == 0 or (n == 1 and arr[0] == 0):\n        return 0\n    \n    arr = [str(x) for x in arr]\n    arr.sort(key=lambda x: x * 10, reverse=True)\n    \n    return int(''.join(arr))", "tests_source": "initial_tests.jsonl", "tests_task_id": "57", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T15:30:15.095052", "stage": "code_generation"}
{"task_id": "58", "round": 1, "temperature": 0.1, "generated_code": "def opposite_Signs(x, y):\n    if not isinstance(x, int) or not isinstance(y, int):\n        raise TypeError(\"Both arguments must be integers\")\n    return (x < 0) != (y < 0)", "tests_source": "initial_tests.jsonl", "tests_task_id": "58", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T15:30:26.229990", "stage": "code_generation"}
{"task_id": "59", "round": 1, "temperature": 0.1, "generated_code": "def is_octagonal(n):\n    if not isinstance(n, int):\n        raise TypeError(\"unsupported operand type\")\n    if n < 0:\n        raise ValueError(\"negative integer\")\n    return 3 * n * n - 2 * n", "tests_source": "initial_tests.jsonl", "tests_task_id": "59", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T15:30:55.585294", "stage": "code_generation"}
{"task_id": "60", "round": 1, "temperature": 0.1, "generated_code": "def max_len_sub(arr, n):\n    if arr is None or n is None:\n        raise TypeError(\"Input cannot be None\")\n    if n < 0:\n        raise ValueError(\"Input size cannot be negative\")\n    \n    if n == 0:\n        return 0\n    \n    mls = [1] * n\n    max_length = 1\n    \n    for i in range(1, n):\n        for j in range(i):\n            if abs(arr[i] - arr[j]) <= 1:\n                mls[i] = max(mls[i], mls[j] + 1)\n        max_length = max(max_length, mls[i])\n    \n    return max_length", "tests_source": "initial_tests.jsonl", "tests_task_id": "60", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T15:31:16.561228", "stage": "code_generation"}
{"task_id": "61", "round": 1, "temperature": 0.1, "generated_code": "from collections import defaultdict\n\ndef count_Substrings(s, n):\n    if not isinstance(s, str) or not isinstance(n, int):\n        raise TypeError(\"string indices must be integers\")\n    if any(c not in '0123456789' for c in s):\n        raise ValueError(\"invalid literal for int() with base 10\")\n    \n    count, sum = 0, 0\n    mp = defaultdict(lambda: 0)\n    mp[0] += 1\n    \n    for i in range(n):\n        sum += ord(s[i]) - ord('0')\n        count += mp[sum - (i + 1)]\n        mp[sum - (i + 1)] += 1\n        \n    return count", "tests_source": "initial_tests.jsonl", "tests_task_id": "61", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T15:31:30.041258", "stage": "code_generation"}
{"task_id": "62", "round": 1, "temperature": 0.1, "generated_code": "def smallest_num(xs):\n    if not xs:\n        raise ValueError(\"min() arg is an empty sequence\")\n    \n    smallest = xs[0]\n    for num in xs:\n        if num is None:\n            raise TypeError(\"unsupported operand type(s) for min: 'NoneType' and 'int'\")\n        if not isinstance(num, (int, float)):\n            raise TypeError(\"unsupported operand type(s) for min: 'str' and 'int'\")\n        if num < smallest:\n            smallest = num\n    return smallest", "tests_source": "initial_tests.jsonl", "tests_task_id": "62", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T15:31:54.426967", "stage": "code_generation"}
{"task_id": "63", "round": 1, "temperature": 0.1, "generated_code": "def max_difference(test_list):\n    if not isinstance(test_list, list):\n        raise TypeError(\"Input must be a list of tuples\")\n    \n    if not test_list:\n        return 0\n    \n    max_diff = 0\n    for pair in test_list:\n        if not isinstance(pair, tuple) or len(pair) != 2:\n            raise TypeError(\"Each item in the list must be a tuple of two elements\")\n        \n        a, b = pair\n        if not isinstance(a, (int, float)) or not isinstance(b, (int, float)):\n            raise TypeError(\"Tuple elements must be numbers\")\n        \n        max_diff = max(max_diff, abs(b - a))\n    \n    return max_diff", "tests_source": "initial_tests.jsonl", "tests_task_id": "63", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T15:32:21.212218", "stage": "code_generation"}
{"task_id": "64", "round": 1, "temperature": 0.1, "generated_code": "def subject_marks(subjectmarks):\n    if not all(isinstance(item, tuple) and len(item) == 2 for item in subjectmarks):\n        raise TypeError(\"unhashable type: 'list'\")\n    if not all(isinstance(score, (int, float)) for _, score in subjectmarks):\n        raise TypeError(\"Invalid score type\")\n    \n    subjectmarks.sort(key=lambda x: x[1])\n    return subjectmarks", "tests_source": "initial_tests.jsonl", "tests_task_id": "64", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T15:32:38.324542", "stage": "code_generation"}
{"task_id": "65", "round": 1, "temperature": 0.1, "generated_code": "def recursive_list_sum(data_list):\n    total = 0\n    for element in data_list:\n        if isinstance(element, list):\n            total += recursive_list_sum(element)\n        elif isinstance(element, (int, float)):\n            total += element\n        else:\n            raise TypeError(\"unsupported operand type\")\n    return total", "tests_source": "initial_tests.jsonl", "tests_task_id": "65", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T15:32:54.993835", "stage": "code_generation"}
{"task_id": "66", "round": 1, "temperature": 0.1, "generated_code": "def pos_count(lst):\n    if not isinstance(lst, list):\n        raise TypeError(\"Input must be a list\")\n    \n    pos_count = 0\n    for num in lst:\n        if not isinstance(num, (int, float)):\n            raise TypeError(\"unsupported operand type\")\n        if num >= 0:\n            pos_count += 1\n    return pos_count", "tests_source": "initial_tests.jsonl", "tests_task_id": "66", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T15:33:06.030317", "stage": "code_generation"}
{"task_id": "67", "round": 1, "temperature": 0.1, "generated_code": "def bell_number(n):\n    if not isinstance(n, int) or n < 0:\n        raise IndexError(\"list index out of range\")\n    \n    bell = [[0 for _ in range(n + 1)] for _ in range(n + 1)]\n    bell[0][0] = 1\n    \n    for i in range(1, n + 1):\n        bell[i][0] = bell[i - 1][i - 1]\n        for j in range(1, i + 1):\n            bell[i][j] = bell[i - 1][j - 1] + bell[i][j - 1]\n    \n    return bell[n][0]", "tests_source": "initial_tests.jsonl", "tests_task_id": "67", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T15:33:17.060467", "stage": "code_generation"}
{"task_id": "68", "round": 1, "temperature": 0.1, "generated_code": "def is_Monotonic(A):\n    if A is None or not isinstance(A, list):\n        raise TypeError(\"Input must be a list\")\n    \n    if len(A) <= 1:\n        return True\n    \n    increasing = decreasing = True\n    \n    for i in range(1, len(A)):\n        if A[i] < A[i - 1]:\n            increasing = False\n        if A[i] > A[i - 1]:\n            decreasing = False\n            \n    return increasing or decreasing", "tests_source": "initial_tests.jsonl", "tests_task_id": "68", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T15:33:59.263698", "stage": "code_generation"}
{"task_id": "69", "round": 1, "temperature": 0.1, "generated_code": "def is_sublist(l, s):\n    if l is None or s is None:\n        raise TypeError(\"Input lists cannot be None\")\n    \n    if s == []:\n        return True\n    if len(s) > len(l):\n        return False\n    \n    for i in range(len(l) - len(s) + 1):\n        if l[i:i + len(s)] == s:\n            return True\n            \n    return False", "tests_source": "initial_tests.jsonl", "tests_task_id": "69", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T15:34:18.911982", "stage": "code_generation"}
{"task_id": "70", "round": 1, "temperature": 0.1, "generated_code": "def find_equal_tuple(Input, k):\n    if not isinstance(Input, list) or any(not isinstance(t, tuple) for t in Input):\n        raise TypeError(\"Input must be a list of tuples\")\n    \n    for tuple in Input:\n        if len(tuple) != k:\n            return 0\n    return 1", "tests_source": "initial_tests.jsonl", "tests_task_id": "70", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T15:34:37.667610", "stage": "code_generation"}
{"task_id": "71", "round": 1, "temperature": 0.1, "generated_code": "def comb_sort(nums):\n    if not all(isinstance(x, (int, float)) for x in nums):\n        raise TypeError(\"All elements must be numeric\")\n    \n    shrink_fact = 1.3\n    gaps = len(nums)\n    swapped = True\n    i = 0\n    while gaps > 1 or swapped:\n        gaps = max(1, int(float(gaps) / shrink_fact))\n        swapped = False\n        i = 0\n        while gaps + i < len(nums):\n            if nums[i] > nums[i + gaps]:\n                nums[i], nums[i + gaps] = nums[i + gaps], nums[i]\n                swapped = True\n            i += 1\n    return nums", "tests_source": "initial_tests.jsonl", "tests_task_id": "71", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T15:34:53.934808", "stage": "code_generation"}
{"task_id": "72", "round": 1, "temperature": 0.1, "generated_code": "def dif_Square(n): \n    if not isinstance(n, int):\n        raise TypeError(\"Input must be an integer.\")\n    return n % 4 != 2", "tests_source": "initial_tests.jsonl", "tests_task_id": "72", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T15:35:06.707792", "stage": "code_generation"}
{"task_id": "73", "round": 1, "temperature": 0.1, "generated_code": "import re\n\ndef multiple_split(text):\n    if not isinstance(text, str):\n        raise TypeError(\"expected a string\")\n    return re.split(r'; |, |\\*|\\n', text)", "tests_source": "initial_tests.jsonl", "tests_task_id": "73", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T15:35:18.339151", "stage": "code_generation"}
{"task_id": "74", "round": 1, "temperature": 0.1, "generated_code": "def is_samepatterns(colors, patterns):\n    if not isinstance(colors, list) or not isinstance(patterns, list):\n        raise TypeError(\"Both colors and patterns must be lists.\")\n    \n    if len(colors) != len(patterns):\n        return False\n    \n    sdict = {}\n    pset = set()\n    sset = set()\n    \n    for i in range(len(patterns)):\n        pset.add(patterns[i])\n        sset.add(colors[i])\n        if patterns[i] not in sdict:\n            sdict[patterns[i]] = []\n        sdict[patterns[i]].append(colors[i])\n\n    if len(pset) != len(sset):\n        return False\n\n    for values in sdict.values():\n        if len(set(values)) > 1:\n            return False\n\n    return True", "tests_source": "initial_tests.jsonl", "tests_task_id": "74", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T15:35:32.186322", "stage": "code_generation"}
{"task_id": "75", "round": 1, "temperature": 0.1, "generated_code": "def find_tuples(test_list, K):\n    if not isinstance(test_list, list) or not isinstance(K, (int, float)):\n        raise TypeError(\"Invalid input types\")\n    \n    res = [sub for sub in test_list if all(isinstance(ele, (int, float)) and ele % K == 0 for ele in sub)]\n    return str(res)", "tests_source": "initial_tests.jsonl", "tests_task_id": "75", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T15:36:05.834364", "stage": "code_generation"}
{"task_id": "76", "round": 1, "temperature": 0.1, "generated_code": "def count_Squares(m, n):\n    if not isinstance(m, int) or not isinstance(n, int):\n        raise TypeError(\"unsupported operand type\")\n    \n    if m < 0 or n < 0:\n        return 0\n    \n    if n < m:\n        temp = m\n        m = n\n        n = temp\n    \n    total_squares = (m * (m + 1) * (2 * m + 1) / 6) + ((n - m) * m * (m + 1) / 2)\n    return total_squares", "tests_source": "initial_tests.jsonl", "tests_task_id": "76", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T15:36:28.189046", "stage": "code_generation"}
{"task_id": "77", "round": 1, "temperature": 0.1, "generated_code": "def is_Diff(n):\n    if not isinstance(n, int):\n        raise TypeError(\"unsupported operand type\")\n    return n % 11 == 0", "tests_source": "initial_tests.jsonl", "tests_task_id": "77", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T15:37:02.208691", "stage": "code_generation"}
{"task_id": "78", "round": 1, "temperature": 0.1, "generated_code": "def count_With_Odd_SetBits(n):\n    if not isinstance(n, int):\n        raise TypeError(\"unsupported operand type\")\n    \n    if n < 0:\n        return 0\n    \n    count = 0\n    for i in range(n + 1):\n        if bin(i).count('1') % 2 != 0:\n            count += 1\n            \n    return count", "tests_source": "initial_tests.jsonl", "tests_task_id": "78", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T15:37:34.977163", "stage": "code_generation"}
{"task_id": "79", "round": 1, "temperature": 0.1, "generated_code": "def word_len(s):\n    if not isinstance(s, str):\n        raise AttributeError(\"Input must be a string\")\n    \n    s = s.split(' ')\n    for word in s:\n        if len(word) % 2 != 0:\n            return True\n    return False", "tests_source": "initial_tests.jsonl", "tests_task_id": "79", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T15:37:51.012025", "stage": "code_generation"}
{"task_id": "80", "round": 1, "temperature": 0.1, "generated_code": "def tetrahedral_number(n):\n    if not isinstance(n, int):\n        raise TypeError(\"unsupported operand type\")\n    if n < 0:\n        raise ValueError(\"negative value\")\n    return (n * (n + 1) * (n + 2)) // 6", "tests_source": "initial_tests.jsonl", "tests_task_id": "80", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T15:38:01.544523", "stage": "code_generation"}
{"task_id": "81", "round": 1, "temperature": 0.1, "generated_code": "def zip_tuples(test_tup1, test_tup2):\n    if not isinstance(test_tup1, tuple) or not isinstance(test_tup2, tuple):\n        raise TypeError(\"Both inputs must be tuples.\")\n    \n    len1, len2 = len(test_tup1), len(test_tup2)\n    \n    if len1 == 0 and len2 == 0:\n        return []\n    elif len1 == 0:\n        return [(None, test_tup2[i]) for i in range(len2)]\n    elif len2 == 0:\n        return [(test_tup1[i], None) for i in range(len1)]\n    \n    if len1 != len2:\n        raise IndexError(\"The lengths of the tuples must match.\")\n    \n    return [(test_tup1[i], test_tup2[i]) for i in range(len1)]", "tests_source": "initial_tests.jsonl", "tests_task_id": "81", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T15:38:14.415539", "stage": "code_generation"}
{"task_id": "82", "round": 1, "temperature": 0.1, "generated_code": "import math\n\ndef volume_sphere(r):\n    if not isinstance(r, (int, float)):\n        raise TypeError(\"must be a number\")\n    if r < 0:\n        raise ValueError(\"Radius cannot be negative\")\n    volume = (4/3) * math.pi * r**3\n    return volume", "tests_source": "initial_tests.jsonl", "tests_task_id": "82", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T15:38:40.047255", "stage": "code_generation"}
{"task_id": "83", "round": 1, "temperature": 0.1, "generated_code": "def get_Char(strr):\n    if not isinstance(strr, str):\n        raise TypeError(\"string expected\")\n    \n    if len(strr) == 0:\n        return 'z'\n    \n    summ = 0\n    for char in strr:\n        if 'a' <= char <= 'z':\n            summ += (ord(char) - ord('a') + 1)\n        else:\n            raise ValueError(\"Invalid character in string\")\n    \n    summ = summ % 26\n    if summ == 0:\n        return 'z'\n    else:\n        return chr(ord('a') + summ - 1)", "tests_source": "initial_tests.jsonl", "tests_task_id": "83", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T15:38:51.162881", "stage": "code_generation"}
{"task_id": "84", "round": 1, "temperature": 0.1, "generated_code": "def sequence(n):\n    if not isinstance(n, int):\n        raise TypeError(\"must be an integer\")\n    if n <= 0:\n        raise ValueError(\"must be a positive integer\")\n    \n    if n == 1 or n == 2:\n        return 1\n    \n    # Create a list to store the sequence values\n    seq = [0] * (n + 1)\n    seq[1], seq[2] = 1, 1\n    \n    for i in range(3, n + 1):\n        seq[i] = seq[seq[i - 1]] + seq[i - seq[i - 1]]\n    \n    return seq[n]", "tests_source": "initial_tests.jsonl", "tests_task_id": "84", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T15:39:25.644622", "stage": "code_generation"}
{"task_id": "85", "round": 1, "temperature": 0.1, "generated_code": "import math\n\ndef surfacearea_sphere(r):\n    if r < 0:\n        raise ValueError(\"Radius cannot be negative\")\n    return 4 * math.pi * r * r", "tests_source": "initial_tests.jsonl", "tests_task_id": "85", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T15:39:43.550459", "stage": "code_generation"}
{"task_id": "86", "round": 1, "temperature": 0.1, "generated_code": "def centered_hexagonal_number(n):\n    if not isinstance(n, int):\n        raise TypeError(\"unsupported operand type\")\n    if n < 0:\n        raise ValueError(\"negative integer\")\n    return 3 * n * (n - 1) + 1 if n > 0 else 1", "tests_source": "initial_tests.jsonl", "tests_task_id": "86", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T15:39:53.628654", "stage": "code_generation"}
{"task_id": "87", "round": 1, "temperature": 0.1, "generated_code": "def merge_dictionaries_three(dict1, dict2, dict3):\n    if not all(isinstance(d, dict) for d in (dict1, dict2, dict3)):\n        raise TypeError(\"expected a dictionary\")\n    return {**dict1, **dict2, **dict3}", "tests_source": "initial_tests.jsonl", "tests_task_id": "87", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T15:40:31.114980", "stage": "code_generation"}
{"task_id": "88", "round": 1, "temperature": 0.1, "generated_code": "import collections\n\ndef freq_count(list1):\n    if list1 is None:\n        raise TypeError(\"Input cannot be None\")\n    if not all(isinstance(item, (str, int, float)) for item in list1):\n        raise TypeError(\"All elements must be of type str, int, or float\")\n    \n    return collections.Counter(list1)", "tests_source": "initial_tests.jsonl", "tests_task_id": "88", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T15:40:40.060600", "stage": "code_generation"}
{"task_id": "89", "round": 1, "temperature": 0.1, "generated_code": "def closest_num(N):\n    if not isinstance(N, (int, float)):\n        raise TypeError(\"unsupported operand type(s) for -: 'str' and 'int'\")\n    return N - 1", "tests_source": "initial_tests.jsonl", "tests_task_id": "89", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T15:40:54.521130", "stage": "code_generation"}
{"task_id": "90", "round": 1, "temperature": 0.1, "generated_code": "def len_log(list1):\n    if not list1:\n        raise IndexError(\"list index out of range\")\n    \n    max_length = 0\n    for item in list1:\n        if not isinstance(item, str):\n            raise TypeError(f\"object of type '{type(item).__name__}' has no len()\")\n        max_length = max(max_length, len(item))\n    \n    return max_length", "tests_source": "initial_tests.jsonl", "tests_task_id": "90", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T15:41:05.892527", "stage": "code_generation"}
{"task_id": "91", "round": 1, "temperature": 0.1, "generated_code": "def find_substring(str1, sub_str):\n    if not isinstance(str1, list) or not all(isinstance(s, str) for s in str1):\n        raise TypeError(\"First argument must be a list of strings\")\n    if not isinstance(sub_str, str):\n        raise TypeError(\"Second argument must be a string\")\n    \n    return any(sub_str in s for s in str1)", "tests_source": "initial_tests.jsonl", "tests_task_id": "91", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T15:41:20.671066", "stage": "code_generation"}
{"task_id": "92", "round": 1, "temperature": 0.1, "generated_code": "def is_undulating(n):\n    if not isinstance(n, list):\n        raise TypeError(\"Input must be a list\")\n    if len(n) < 3:\n        return False\n    for i in range(len(n)):\n        if not isinstance(n[i], (int, float)):\n            raise TypeError(\"List must contain only numbers\")\n    for i in range(2, len(n)):\n        if n[i - 2] != n[i]:\n            return False\n    return True", "tests_source": "initial_tests.jsonl", "tests_task_id": "92", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T15:41:31.111074", "stage": "code_generation"}
{"task_id": "93", "round": 1, "temperature": 0.1, "generated_code": "def power(a, b):\n    if not isinstance(a, (int, float)) or not isinstance(b, (int, float)):\n        raise TypeError(\"unsupported operand type(s) for power: '{}' and '{}'\".format(type(a).__name__, type(b).__name__))\n    \n    if b == 0:\n        return 1\n    elif a == 0:\n        return 0\n    elif b == 1:\n        return a\n    elif b < 0:\n        return 1 / power(a, -b)\n    else:\n        return a * power(a, b - 1)", "tests_source": "initial_tests.jsonl", "tests_task_id": "93", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T15:41:51.879446", "stage": "code_generation"}
{"task_id": "94", "round": 1, "temperature": 0.1, "generated_code": "from operator import itemgetter \n\ndef index_minimum(test_list):\n    if not isinstance(test_list, list):\n        raise TypeError(\"unhashable type: 'list'\")\n    if not test_list:\n        raise ValueError(\"min() arg is an empty sequence\")\n    \n    for record in test_list:\n        if not isinstance(record, tuple) or len(record) != 2:\n            raise TypeError(\"Invalid tuple structure\")\n        if not isinstance(record[1], (int, float)):\n            raise TypeError(\"Invalid value type in tuple\")\n    \n    res = min(test_list, key=itemgetter(1))[0]\n    return res", "tests_source": "initial_tests.jsonl", "tests_task_id": "94", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T15:42:14.631064", "stage": "code_generation"}
{"task_id": "95", "round": 1, "temperature": 0.1, "generated_code": "def Find_Min_Length(lst):\n    if not lst:\n        raise ValueError(\"min() arg is an empty sequence\")\n    \n    minLength = float('inf')\n    \n    for sublist in lst:\n        if not isinstance(sublist, list):\n            raise TypeError(f\"object of type '{type(sublist).__name__}' has no len()\")\n        minLength = min(minLength, len(sublist))\n    \n    return minLength", "tests_source": "initial_tests.jsonl", "tests_task_id": "95", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T15:42:35.142594", "stage": "code_generation"}
{"task_id": "96", "round": 1, "temperature": 0.1, "generated_code": "def divisor(n):\n    if not isinstance(n, int):\n        raise TypeError(\"unsupported operand type\")\n    if n < 1:\n        return 0\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count", "tests_source": "initial_tests.jsonl", "tests_task_id": "96", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T15:42:52.795041", "stage": "code_generation"}
{"task_id": "97", "round": 1, "temperature": 0.1, "generated_code": "def frequency_lists(list1):\n    if not isinstance(list1, list):\n        raise TypeError(\"Input must be a list\")\n    \n    dic_data = {}\n    for sublist in list1:\n        if not isinstance(sublist, list):\n            raise TypeError(\"All elements of the input list must be lists\")\n        for num in sublist:\n            dic_data[num] = dic_data.get(num, 0) + 1\n    return dic_data", "tests_source": "initial_tests.jsonl", "tests_task_id": "97", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T15:43:05.831331", "stage": "code_generation"}
{"task_id": "98", "round": 1, "temperature": 0.1, "generated_code": "def multiply_num(numbers):\n    if not isinstance(numbers, list):\n        raise TypeError(\"Input must be a list\")\n    if len(numbers) == 0:\n        raise ZeroDivisionError(\"Division by zero when length is zero\")\n    \n    total = 1\n    for x in numbers:\n        if not isinstance(x, (int, float)):\n            raise TypeError(\"All elements must be numbers\")\n        total *= x\n    \n    return total / len(numbers)", "tests_source": "initial_tests.jsonl", "tests_task_id": "98", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T15:43:18.548596", "stage": "code_generation"}
{"task_id": "99", "round": 1, "temperature": 0.1, "generated_code": "def decimal_to_binary(n):\n    if not isinstance(n, int):\n        raise TypeError(\"must be an integer\")\n    if n < 0:\n        n = (1 << (n.bit_length() + 1)) + n  # Two's complement for negative numbers\n    return bin(n).replace(\"0b\", \"\")", "tests_source": "initial_tests.jsonl", "tests_task_id": "99", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T15:43:54.756314", "stage": "code_generation"}
{"task_id": "100", "round": 1, "temperature": 0.1, "generated_code": "def next_smallest_palindrome(num):\n    if not isinstance(num, int):\n        raise TypeError(\"unsupported operand type\")\n    if num < 0:\n        raise ValueError(\"negative number\")\n    \n    num += 1\n    while True:\n        if str(num) == str(num)[::-1]:\n            return num\n        num += 1", "tests_source": "initial_tests.jsonl", "tests_task_id": "100", "method": "iterative_repair_mbpp", "model": "gpt-4o-mini", "timestamp": "2025-09-03T15:44:21.363943", "stage": "code_generation"}
